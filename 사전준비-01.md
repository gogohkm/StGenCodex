아래는 “개발 문서 수준”으로 바로 착수할 수 있게, (1) VS Code Extension 구조/manifest, (2) Chat Participant + Tool 설계, (3) MCP 서버(스킬) 설계 + mcp.json 예시, (4) 프로젝트 DB 스키마 초안, (5) 도면↔해석↔체크 매핑 UX 플로우까지 한 번에 내려쓴 구상안입니다.

전제(중요)

구조안전성 평가는 LLM이 계산/판정을 직접 하지 않고, “결정론 엔진(코드체크/해석)”이 수행하고 LLM은 계획·누락탐지·설명·근거 제시·워크플로 오케스트레이션만 담당하도록 설계합니다. (감사/재현성/책임 문제 대응)

1) 전체 시스템 아키텍처 (권장)
1.1 구성요소

VS Code Extension (TypeScript)

오른쪽(Secondary Sidebar/Panel)에:

“AI 대화/작업” UI

“프로젝트 메모리(가정/재료/하중/버전/상태)” UI

“도면/모델/결과 뷰어” UI(Webview/Custom Editor)

VS Code Chat에 Chat Participant(@struct) 등록: 사용자가 @struct로 호출하면 엔드투엔드로 작업을 오케스트레이션. 
Visual Studio Code
+1

에이전트/툴 호출을 위해 Language Model Tools(확장 도구) 등록. 
Visual Studio Code
+1

로컬 백엔드(권장: Python)

문서 인덱싱(RAG), 도면 파싱, 해석 실행/파싱, 코드체크(결정론), 리포트 생성

이 백엔드는 2가지 형태 중 택1 또는 병행:

(A) MCP Server로 노출 (Claude 스킬 스타일): VS Code는 MCP 도구를 그대로 사용 가능 
Visual Studio Code
+1

(B) Extension이 내부적으로 로컬 서비스 호출(HTTP/stdio)

Project Storage (단일 “메모리”)

구조화 DB(객체/관계/이력) + 벡터 인덱스(문서/근거)

핵심은 “부재ID ↔ 도면객체ID ↔ 해석요소ID ↔ 결과 ↔ 기준 조항/표” 링크가 항상 유지되는 것

2) 모노레포 구조 제안 (바로 만들 수 있게)
structai/
  packages/
    vscode-extension/                 # VS Code 확장 (TS)
      package.json
      src/
        extension.ts
        chat/
          participant.ts
          intents.ts
          prompt.ts
        tools/
          projectTools.ts
          uiTools.ts
          safetyTools.ts
        views/
          memoryView.ts
          mappingView.ts
          resultsView.ts
        editors/
          ifcEditor.ts
          dxfEditor.ts
          feaResultEditor.ts
        common/
          types.ts
          rpc.ts
      media/
        icons/
        webview-dist/                 # React/Vite 등으로 빌드된 정적 파일
    mcp-server/                       # MCP 서버 (Python)
      pyproject.toml
      structai_mcp/
        __init__.py
        server.py                     # MCP 엔트리
        tools/
          docs.py
          cad.py
          model.py
          fea.py
          checks.py
          report.py
        storage/
          db.py
          schema.sql
          vector.py
        adapters/
          opensees.py
          etabs.py
          sap2000.py
  schemas/
    toolSchemas/
    db/
      schema.sql
  samples/
    demo_project/

3) VS Code Extension Manifest 설계 (package.json)
3.1 Chat Participant 등록

VS Code Chat에 “@struct”를 등록합니다. contributes.chatParticipants에 정의하고, 런타임에 vscode.chat.createChatParticipant()로 핸들러를 연결합니다. 
Visual Studio Code
+1

package.json 예시(핵심만)

{
  "name": "structai",
  "publisher": "your-org",
  "main": "./out/extension.js",
  "engines": { "vscode": "^1.107.0" },
  "activationEvents": [
    "onStartupFinished",
    "onView:structai.memory",
    "onView:structai.mapping",
    "onCommand:structai.openMapping",
    "onCommand:structai.runCheck"
  ],
  "contributes": {
    "chatParticipants": [
      {
        "id": "structai.participant",
        "name": "struct",
        "fullName": "Struct AI",
        "description": "도면/해석/기준을 연결해 구조안전성 검토를 도와드립니다.",
        "isSticky": true,
        "commands": [
          { "name": "import", "description": "PDF/IFC/DXF/MD/해석파일을 프로젝트에 등록" },
          { "name": "assume", "description": "설계 가정/기준버전/단위 설정" },
          { "name": "map", "description": "도면 객체 ↔ 부재 매핑 모드 실행" },
          { "name": "run", "description": "해석 실행/재실행" },
          { "name": "check", "description": "부재/층/전체 구조검토 실행" },
          { "name": "report", "description": "검토서/계산서 생성" }
        ],
        "disambiguation": [
          {
            "category": "structural_engineering",
            "description": "도면, 해석결과, 기준 문서를 바탕으로 구조검토/리포트가 필요한 질문",
            "examples": [
              "B12 보 ULS1 검토해줘",
              "이 기둥 축력비가 왜 커졌는지 설명해줘",
              "KDS 기준에서 전단검토 조항 근거 보여줘"
            ]
          }
        ]
      }
    ]
  }
}

3.2 Language Model Tools(확장 도구) 등록

에이전트가 자동 호출할 수 있는 “확장 도구”를 contributes.languageModelTools에 선언하고, 런타임에 vscode.lm.registerTool()로 등록합니다.

inputSchema는 JSON Schema로 정의

prepareInvocation으로 사용자 승인 메시지(툴 실행 확인) 제공 가능 
Visual Studio Code
+1

package.json 예시(도구 2개만 샘플)

{
  "contributes": {
    "languageModelTools": [
      {
        "name": "structai_getActiveContext",
        "displayName": "Get Active Struct Context",
        "toolReferenceName": "structContext",
        "canBeReferencedInPrompt": true,
        "icon": "$(organization)",
        "userDescription": "현재 선택된 부재/도면/해석 상태 컨텍스트를 가져옵니다.",
        "modelDescription": "Fetch active selection context from VS Code: selected member, active drawing, active combo, and last run check IDs.",
        "inputSchema": { "type": "object", "properties": {} }
      },
      {
        "name": "structai_openMappingUI",
        "displayName": "Open Mapping UI",
        "toolReferenceName": "openMapping",
        "canBeReferencedInPrompt": true,
        "icon": "$(link)",
        "userDescription": "도면-부재 매핑 UI를 엽니다.",
        "modelDescription": "Open mapping webview to link drawing entities with structural members.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "drawingUri": { "type": "string", "description": "Absolute file URI or path" }
          },
          "required": ["drawingUri"]
        }
      }
    ]
  }
}


팁: “계산/판정” 관련 툴은 **항상 승인(confirm)**을 요구하도록 prepareInvocation에 메시지를 넣는 것을 추천합니다. 
Visual Studio Code

3.3 Views(오른쪽 패널 UI) 구성

VS Code의 뷰는 사이드바/패널에 표시되는 컨테이너입니다. “StructAI” 전용 컨테이너를 Secondary Sidebar에 두고, 그 아래에 2~3개 뷰만(과도하게 늘리지 않기) 붙이는 전략이 안정적입니다. 
Visual Studio Code

권장 뷰 구성

StructAI: Memory (TreeView or WebviewView)

StructAI: Mapping (WebviewView)

StructAI: Results (WebviewView)

도면/결과 같이 무거운 UI는 Webview가 적합하고, VS Code는 webview를 “패널/커스텀 에디터/사이드바 뷰” 등으로 쓸 수 있습니다. 
Visual Studio Code
+1

4) Extension 런타임 구현 스켈레톤
4.1 extension.ts (activate)

Chat participant 생성: vscode.chat.createChatParticipant(id, handler) 
Visual Studio Code
+1

도구 등록: vscode.lm.registerTool(name, toolInstance) 
Visual Studio Code

WebviewView/CustomEditor 등록

백엔드(MCP 또는 내부 서비스) 연결 상태 관리

import * as vscode from "vscode";
import { registerStructParticipant } from "./chat/participant";
import { registerStructTools } from "./tools";

export async function activate(ctx: vscode.ExtensionContext) {
  registerStructParticipant(ctx);     // chat participant
  registerStructTools(ctx);           // lm tools
  // register views/editors...
}

4.2 Chat Participant 핸들러 설계

핸들러는:

컨텍스트 수집(선택된 부재/활성 도면/조합/최근 체크)

계획(Plan): 어떤 도구를 어떤 순서로 호출할지

도구 호출(확장 도구 + MCP 도구)

응답 스트리밍(progress/filetree/button/reference 등)

VS Code ChatResponseStream은 버튼/파일트리/진행상태/레퍼런스를 지원합니다. (UI 액션을 채팅에서 바로 실행) 
Visual Studio Code
+1

export function registerStructParticipant(ctx: vscode.ExtensionContext) {
  const handler: vscode.ChatRequestHandler = async (req, chatCtx, stream, token) => {
    stream.progress("StructAI: 컨텍스트 수집 중..."); // 진행 표시 :contentReference[oaicite:11]{index=11}

    // 1) 현재 컨텍스트 가져오기 (확장 도구 또는 직접 API)
    // 2) req.command (/import,/check,...)에 따라 분기
    // 3) 백엔드(MCP) 호출 -> 결과 수신
    // 4) stream.markdown / stream.button / stream.reference 등으로 응답
  };

  const participant = vscode.chat.createChatParticipant("structai.participant", handler);
  participant.iconPath = vscode.Uri.joinPath(ctx.extensionUri, "media/icons/struct.png");
}

5) “도구(스킬)” 설계: Extension Tools vs MCP Tools
5.1 분리 원칙

Extension Tool(경량/IDE 컨텍스트 의존)

VS Code 선택 영역, 활성 파일, 에디터 열기, Webview 열기, diff 보여주기, 워크스페이스 파일 생성 등

MCP Tool(중량/도메인 엔진)

PDF/CAD 파싱, 임베딩/검색, 해석 실행, 결과 파싱, 코드 체크, 보고서 생성

VS Code는 “확장 도구”와 “MCP 도구”를 모두 툴로 취급합니다. 
Visual Studio Code
+1

5.2 Extension Tools(추천 최소 세트)

아래는 “LLM이 IDE와 상호작용”하기 위한 최소 도구입니다(8~12개 선 권장).

structai_getActiveContext

입력 없음, 출력: { activeMemberId, activeDrawingUri, activeComboId, lastCheckRunId, selectionRange, ... }

structai_openUri

문서/도면/리포트 파일 열기

structai_openMappingUI(drawingUri)

매핑 Webview 열기

structai_openResultsUI(checkRunId?)

structai_writeReportFile(path, markdown)

마크다운 계산서 생성

structai_applyModelPatch(patch)

모델 변경(부재 단면/재료/하중) 적용 — 항상 confirm 필요

structai_showDiff(before, after)

변경점(가정/입력/단면 등) 비교 표시

structai_selectMember(memberId)

UI 동기화(선택 변경)

Tool API에서 prepareInvocation로 “사용자 승인 메시지”를 커스터마이즈할 수 있습니다. 
Visual Studio Code

6) MCP 서버 설계(Claude 스킬 방식)
6.1 MCP 설정 파일(.vscode/mcp.json) 예시

VS Code는 워크스페이스에 .vscode/mcp.json을 두면 팀이 공유 가능합니다. 
Visual Studio Code
+1

또한 stdio 서버는 type: "stdio", command, args, env 등을 지원합니다. 
Visual Studio Code

{
  "inputs": [
    {
      "id": "structaiApiKey",
      "type": "promptString",
      "description": "선택: 외부 LLM 사용 시 API 키"
    }
  ],
  "servers": {
    "structai-local": {
      "type": "stdio",
      "command": "python",
      "args": ["-m", "structai_mcp.server"],
      "env": {
        "STRUCTAI_WORKSPACE": "${workspaceFolder}",
        "STRUCTAI_API_KEY": "${input:structaiApiKey}"
      }
    }
  }
}

6.2 MCP Tools 목록(권장 20~30개) + 스키마 제안
A) 문서/기준(RAG) 도구

docs.import

입력: { uri, kind: "pdf"|"md"|"code", title?, codeSystem?, version? }

출력: { documentId, pages?, chunks, warnings[] }

docs.search

입력: { query, filters?: { codeSystem?, version?, docIds? }, topK }

출력: { hits: [{documentId, chunkId, text, page?, score, citationRef}] }

code.cite_clause

입력: { codeSystem, version, clauseId | query }

출력: { clauseId, title, textExcerpt, source: {documentId, page}, applicability }

docs.extract_tables

입력: { documentId, pageRange? }

출력: { tables:[{tableId, rows, caption, page}] }

B) CAD/도면 도구

cad.import

입력: { uri, format:"ifc"|"dxf"|"dwg"(옵션), units?, axis? }

출력: { drawingId, layers?, entitiesCount, warnings[] }

cad.list_entities

입력: { drawingId, filters?: { layer?, type?, textContains? } }

출력: { entities:[{entityId,type,layer,bbox,properties}] }

cad.get_entity_context

입력: { drawingId, entityId }

출력: { entity: {...}, nearbyText:[], inferredLabelCandidates:[] }

cad.suggest_member_mapping

입력: { drawingId, strategy:"byLabel"|"byGrid"|"byLayer"|"hybrid", threshold }

출력: { suggestions:[{entityId, memberCandidateId, confidence, reason}] }

C) 구조 모델(메모리) 도구

model.get_project_summary

출력: { codeSystem, version, assumptions, memberStats, lastRun }

model.list_members

입력: { type?:"beam"|"column"|"wall"|"slab", story?, tag?, limit }

출력: { members:[{memberId,name,type,story,sectionId,materialId}] }

model.get_member

입력: { memberId }

출력: { member, section, material, loads, mappings, lastCheck }

model.upsert_member

입력: { member: {...} }

출력: { memberId, changedFields }

model.set_assumptions

입력: { assumptionsPatch: {...} }

출력: { applied, diff }

D) 매핑(도면↔부재↔해석) 도구

map.link_drawing_entity

입력: { drawingId, entityId, memberId, method:"manual"|"auto", confidence? }

출력: { mappingId }

map.unlink

입력: { mappingId }

출력: { ok:true }

map.get_unmapped

입력: { drawingId, memberType? }

출력: { entities:[], members:[] }

E) 해석(FEA) 도구

fea.build_model

입력: { engine:"opensees"|"etabs"|"sap2000", options:{...} }

출력: { feaModelId, elementCount, warnings[] }

fea.run

입력: { feaModelId, loadCombos:[...], solverOptions? }

출력: { runId, status, logs, artifacts:{...} }

fea.get_results

입력: { runId, memberIds?, resultTypes:["N","V","M","D","ratio"] }

출력: { results:[{memberId, comboId, values, envelopes}] }

F) 코드체크(결정론) 도구

check.run_member

입력: { memberId, codeSystem, version, comboId, checks:["flexure","shear","axial",...] }

출력: { checkResultId, passFail, utilization, details, citations:[...] }

check.run_project

입력: { scope:{story?}, combos:[...], checks:[...] }

출력: { runId, summary:{pass,fail,warn}, topFailures:[...] }

check.explain_failure

입력: { checkResultId }

출력: { narrative, controllingClause, sensitivityHints }

G) 리포트 도구

report.generate_md

입력: { runId, template:"default"|"kds"|"internal", includeCitations:true }

출력: { uri, sections, warnings }

report.export_pdf

입력: { mdUri, pdfUri? }

출력: { pdfUri }

H) 감사/이력 도구

audit.log_event

입력: { type, payload, relatedIds }

출력: { eventId }

audit.get_timeline

입력: { since?, limit }

출력: { events:[...] }

MCP는 “도구/프롬프트/리소스” 등도 제공 가능한 표준이고, VS Code는 MCP를 통해 AI 에이전트를 외부 도구에 연결합니다. 
Visual Studio Code
+1

7) Webview/Custom Editor 구현 패턴 (도면/해석/결과 UI)
7.1 Webview 사용 이유와 메시지 패싱

Webview는 iframe처럼 동작하고, 확장과는 메시지 패싱으로 통신합니다. 
Visual Studio Code
+1

extension → webview: webview.postMessage()

webview → extension: window.addEventListener('message', ...) 또는 webview API
또한 webview 내부는 VS Code API에 직접 접근 불가 → 메시지로 요청해야 합니다. 
Visual Studio Code
+1

메시지 프로토콜(권장)
// 공통 메시지 envelope
type RpcMessage =
  | { type: "request"; id: string; method: string; params?: any }
  | { type: "response"; id: string; result?: any; error?: { message: string; data?: any } }
  | { type: "event"; event: string; payload: any };

7.2 Webview 상태 유지

Webview는 백그라운드 탭으로 가면 내부 상태가 날아갈 수 있으니 “stateless + 상태 저장/복원” 전략이 좋습니다(문서에서도 메시지 패싱 기반 복원을 권장). 
Visual Studio Code

8) 프로젝트 DB 스키마 초안 (단일 메모리의 핵심)

아래는 SQLite/Postgres 모두에 맞게 설계한 “링크 가능한 구조”입니다.
(필수: UUID/ULID, created_at/updated_at, 변경 이력)

8.1 핵심 테이블
project

project_id (PK)

name

code_system (KDS/ACI/AISC/…)

code_version

unit_system (SI/US)

metadata_json

documents

document_id (PK)

uri

kind (pdf/md/code/report)

title

code_system, code_version (기준 문서인 경우)

hash, created_at

doc_chunks (RAG)

chunk_id (PK)

document_id (FK)

page_no (pdf)

text

embedding_ref (벡터 스토어 키)

bbox_json (선택: PDF 좌표)

members

member_id (PK)

name (B12/C1 등)

type (beam/column/wall/slab/brace/footing)

story

section_id (FK)

material_id (FK)

geometry_json (라인/축, 길이 등)

tags_json

sections / materials

단면/재료 데이터 분리

load_cases / load_combos

조합 정의 + 식(조합계수)

fea_models / fea_runs / fea_results

fea_model_id, run_id, result_id

결과는 “부재 기준”과 “요소 기준” 둘 다 저장 가능(후자는 용량 큼)

mappings (링크의 핵심)

mapping_id

mapping_type:

"drawingEntityToMember", "feaElementToMember", "textLabelToMember"

source_id (entityId/elementId 등)

member_id

method (manual/auto)

confidence

evidence_json (근거: 주변 텍스트, 규칙, 사용자 확인 등)

checks / check_results

check_run_id

member_id, combo_id

check_type (flexure/shear/axial/interaction/...)

pass_fail, utilization

details_json (중간값/단위/식 ID)

citations_json (조항/페이지/근거 링크)

assumptions / decisions / audit_events

LLM 대화로 정해진 가정/결정의 “감사 가능한” 기록

8.2 벡터 스토어 권장

MVP: 로컬 파일 기반(Chroma/FAISS 등)

팀 공유/서버형: Postgres + pgvector
핵심은 doc_chunks.embedding_ref로 “텍스트 chunk ↔ 임베딩”을 연결하는 것.

9) 도면 ↔ 해석 ↔ 체크 “매핑 UX” 구체 플로우

이 제품이 Cursor와 다르게 “실무”가 되려면, 매핑은 반드시 UI 중심이어야 합니다(LLM 단독 자동매핑은 오차가 큼).

9.1 매핑 모드 화면(권장 레이아웃)

왼쪽: 도면 뷰어(IFC/DXF)

클릭/박스선택/레이어 필터

선택 객체의 속성(레이어, 블록명, 텍스트, 좌표)

오른쪽 상단: 부재 리스트(검색/필터)

story/type/명칭(B12 등) 기반 빠른 검색

“최근 선택/최근 실패 부재” 핀

오른쪽 하단: 추천 매핑(suggestions)

confidence, 이유(근거 텍스트/규칙)

“승인” 버튼으로 확정 링크

9.2 동작 시나리오(상세)

사용자가 /map 또는 버튼으로 매핑 모드 실행

ChatResponseStream.button으로 “매핑 모드 열기” 제공 가능 
Visual Studio Code

도면 클릭 → extension이 cad.get_entity_context 호출

주변 텍스트/치수/그리드 기반 label 후보 추출

백엔드가 cad.suggest_member_mapping으로 후보 생성

예: “C1” 텍스트 근처 → member “C1” 후보

레이어 규칙(예: COL_*) + 스토리/그리드 규칙 혼합

사용자가 후보 선택 후 “Link” 클릭

map.link_drawing_entity 호출

저장 후, 도면 객체/부재 모두에 “링크됨” 배지 표시

링크가 충분히 쌓이면 “Auto-check” 제안

Chat에서 /check scope=linkedOnly 같은 흐름으로 연결

10) 구조 안전성 평가 대화 흐름(에이전트 오케스트레이션) 예시

사용자: @struct /check B12 ULS1 전단이랑 휨 체크해줘

에이전트(내부 플로우):

structai_getActiveContext (혹은 model.get_member)

누락 확인: 기준버전/재료강도/단면/조합정의

필요 시 /assume 가이드 또는 model.set_assumptions

check.run_member(memberId=B12, comboId=ULS1, checks=[flexure,shear])

결과를 채팅에 표로 요약 + stream.reference(...)로 기준/PDF 근거 연결 
Visual Studio Code
+1

“결과 뷰 열기”, “리포트 생성” 버튼 제공 
Visual Studio Code

여기서 중요한 규칙:

채팅 답변은 항상 **(결론) + (근거 인용) + (입력/가정) + (재현 가능한 결과ID)**를 포함

모델 변경이 필요한 경우는 반드시 “승인 + diff”를 보여줌(툴 confirm)

11) 구현 우선순위(실패 확률 낮은 순서)

Chat Participant + Project Memory(assumptions/decisions) + PDF/MD RAG

매핑 UI(최소 기능) + IFC/DXF 뷰어 + 링크 저장

해석 1개 엔진 어댑터(OpenSees 또는 상용 API) + 결과 파싱

코드체크 1개 분야(예: RC 보/기둥)부터 결정론 엔진화

리포트 자동 생성(마크다운 → PDF)

12) 다음에 바로 이어서 할 수 있는 “산출물 5개”

원하면, 위 설계를 기반으로 제가 바로 작성해줄 수 있는 구체 산출물은 아래입니다(원하는 것부터 해도 됨).

package.json 전체 골격(views, commands, editors, menus 포함)

src/chat/participant.ts 실코드(인텐트 라우팅 + 툴 호출 + 스트리밍)

MCP 서버 server.py 골격 + tool registry + pydantic 스키마

schema.sql (SQLite 기준) + 마이그레이션 전략

매핑 Webview UI 와이어프레임(React 기준 컴포넌트 트리 + 메시지 프로토콜)

사용자 입장에선 **(1)~(3)**만 있어도 “@struct로 대화 → 매핑 UI 열기 → 체크 실행 → 리포트 생성”의 뼈대가 돌아가기 시작합니다.

원하는 방향으로 진행할게요:

“MVP를 1번(문서+메모리)부터”인지,

“매핑 UI부터”인지,

아니면 “해석 연동부터”인지에 따라 코드 골격을 먼저 뽑아주면 됩니다.