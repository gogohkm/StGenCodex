아래는 (1) VS Code 확장(package.json) → (2) Chat Participant 실코드 → (3) Python MCP 서버 골격 → (4) SQLite schema.sql → (5) 매핑 Webview 와이어프레임 순서로, 바로 “뼈대가 돌아가는 형태”로 쓸 수 있게 구성해둔 초안입니다.
(설명은 최소화하고, 파일 단위로 복붙 가능한 산출물 위주로 제공합니다.)

0) 권장 폴더 구조
structai-vscode/
  package.json
  tsconfig.json
  src/
    extension.ts
    chat/
      participant.ts
    mcp/
      provider.ts
    views/
      mappingView.ts
  media/
    icons/
      structai.svg
    mapping/
      main.js
      main.css
  server/
    structai_mcp_server.py
    schema.sql
    requirements.txt

1) package.json 전체 골격 (VS Code Extension Manifest)

핵심 포인트

chatParticipants로 @struct(StructAI) 참가자 제공

mcpServerDefinitionProviders로 서버 자동 등록/기동 (VS Code API 기반)

viewsContainers.panel + views로 매핑/메모리/결과 패널 UI 제공

{
  "name": "structai",
  "displayName": "StructAI (Structural Engineering Assistant)",
  "description": "VS Code-integrated structural engineering AI: CAD/PDF/MD/FEA context, unified memory, and code-based safety checks via MCP.",
  "version": "0.0.1",
  "publisher": "your-org",
  "license": "MIT",
  "engines": {
    "vscode": "^1.107.0"
  },
  "categories": ["Other"],
  "main": "./out/extension.js",
  "activationEvents": [
    "onStartupFinished",
    "onChatParticipant:structai.struct",
    "onView:structai.mapping",
    "onView:structai.memory",
    "onView:structai.results"
  ],
  "contributes": {
    "chatParticipants": [
      {
        "id": "structai.struct",
        "name": "struct",
        "fullName": "StructAI",
        "description": "건축구조/구조해석/기준 기반 검토를 위한 AI (CAD/PDF/MD/FEA 통합 메모리)",
        "commands": [
          {
            "name": "import",
            "description": "CAD/PDF/MD/모델 파일을 프로젝트 메모리에 임포트(인덱싱)합니다."
          },
          {
            "name": "map",
            "description": "CAD/문서/해석모델 간 매핑 화면을 엽니다."
          },
          {
            "name": "check",
            "description": "부재/요소/모델에 대해 구조안전성 평가를 수행합니다."
          },
          {
            "name": "report",
            "description": "현재 검토 결과를 리포트 형식으로 정리합니다."
          },
          {
            "name": "reset",
            "description": "현재 프로젝트/세션 메모리를 초기화합니다."
          }
        ],
        "disambiguation": [
          {
            "category": "structural_engineering",
            "description": "건축구조 도면/계산서/PDF 기준/구조해석 모델과 결과를 근거로 구조안전성 평가 및 기준조항 인용이 필요한 질문",
            "examples": [
              "이 부재의 휨/전단 안전율을 기준에 따라 검토해줘",
              "도면에서 보/기둥 라벨을 읽고 해석모델 요소와 매핑해줘",
              "해석 결과를 반영해서 부재별 D/C ratio를 정리해줘",
              "KDS(또는 사내 기준) 조항과 함께 검토 근거를 제시해줘"
            ]
          }
        ]
      }
    ],
    "commands": [
      {
        "command": "structai.openPanel",
        "title": "StructAI: Open Panel (Right)"
      },
      {
        "command": "structai.openMapping",
        "title": "StructAI: Open Mapping View"
      },
      {
        "command": "structai.openMemory",
        "title": "StructAI: Open Memory View"
      },
      {
        "command": "structai.openResults",
        "title": "StructAI: Open Results View"
      }
    ],
    "viewsContainers": {
      "panel": [
        {
          "id": "structai.panel",
          "title": "StructAI",
          "icon": "media/icons/structai.svg"
        }
      ]
    },
    "views": {
      "structai.panel": [
        {
          "id": "structai.mapping",
          "name": "Mapping (CAD ↔ Model ↔ Docs)"
        },
        {
          "id": "structai.memory",
          "name": "Project Memory"
        },
        {
          "id": "structai.results",
          "name": "Checks & Results"
        }
      ]
    },
    "mcpServerDefinitionProviders": [
      {
        "id": "structaiMcpProvider",
        "label": "StructAI MCP Provider"
      }
    ],
    "configuration": {
      "title": "StructAI",
      "properties": {
        "structai.pythonPath": {
          "type": "string",
          "default": "python",
          "description": "StructAI MCP 서버를 실행할 Python 실행 파일 경로"
        },
        "structai.dbPath": {
          "type": "string",
          "default": "",
          "description": "StructAI SQLite DB 경로(비우면 워크스페이스 .structai/structai.db 사용)"
        },
        "structai.autoStartMcp": {
          "type": "boolean",
          "default": true,
          "description": "채팅/뷰 사용 시 MCP 서버 정의를 자동 등록하도록 시도"
        }
      }
    }
  },
  "scripts": {
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "lint": "echo \"(lint placeholder)\"",
    "package": "vsce package"
  },
  "dependencies": {
    "@vscode/chat-extension-utils": "^0.3.0"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "@types/vscode": "^1.107.0",
    "typescript": "^5.5.0"
  }
}

2) src/chat/participant.ts 실코드 (Chat Participant + Tool Calling Loop)

핵심 포인트

VS Code Chat Participant는 핸들러에서 LLM 요청/툴 호출 루프를 돌릴 수 있고, @vscode/chat-extension-utils가 이 과정을 크게 단순화합니다.

여기서는 “StructAI 도메인 툴”만 우선 쓰도록 tool 이름 prefix(structai_) 기반 필터를 걸었습니다.

/map, /reset 등 일부는 LLM 없이 즉시 UI/메모리 조작으로 처리.

// src/chat/participant.ts
import * as vscode from 'vscode';
import * as chatUtils from '@vscode/chat-extension-utils';

const PARTICIPANT_ID = 'structai.struct';

export function registerStructChatParticipant(context: vscode.ExtensionContext) {
  const handler: vscode.ChatRequestHandler = async (
    request: vscode.ChatRequest,
    chatContext: vscode.ChatContext,
    stream: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ) => {
    // 1) 일부 커맨드는 즉시 처리 (LLM 불필요)
    if (request.command === 'map') {
      await vscode.commands.executeCommand('structai.openMapping');
      stream.markdown(
        [
          '매핑 뷰를 열었습니다.',
          '',
          '- 왼쪽: 소스(CAD/PDF/MD/FE 모델) 선택',
          '- 가운데: 매핑 테이블(소스 → 타겟)',
          '- 오른쪽: 선택 항목 상세/검증/자동매핑',
          '',
          '원하면 “어떤 도면 레이어/부재 규칙으로 자동 매핑할지”를 자연어로 말해줘도 됩니다.'
        ].join('\n')
      );
      return { metadata: { command: 'map' } };
    }

    if (request.command === 'reset') {
      // 서버 쪽 메모리 초기화는 MCP tool로 처리하는 게 일반적.
      // 여기서는 사용자에게 'structai_reset_project' tool 사용을 유도하는 방식으로 처리.
      stream.markdown(
        [
          '프로젝트 메모리를 초기화하려면 MCP 도구를 사용합니다.',
          '',
          '다음 중 하나로 진행하세요:',
          '- 채팅에서: `#structai_reset_project` 를 실행 (Agent 모드에서 가능)',
          '- 또는: `/check` 같은 작업을 실행하면 필요한 경우 제가 초기화를 제안합니다.'
        ].join('\n')
      );
      return { metadata: { command: 'reset' } };
    }

    // 2) StructAI 도메인 프롬프트 구성
    const prompt = buildStructSystemPrompt();

    // 3) 사용 가능한 툴 선택
    // - MCP 서버/확장 툴을 포함해 vscode.lm.tools 전체 중
    //   이름이 structai_ 로 시작하는 도구만 LLM에게 제공(노이즈 최소화)
    const tools = vscode.lm.tools.filter(t => (t as any).name?.startsWith('structai_'));

    // 4) chat-extension-utils로 tool calling loop + streaming 처리
    // docs: sendChatParticipantRequest 옵션(프롬프트/툴/스트리밍 등) 
    const libResult = chatUtils.sendChatParticipantRequest(
      request,
      chatContext,
      {
        prompt,
        tools,
        responseStreamOptions: {
          stream,
          references: true,
          responseText: true
        },
        extensionMode: context.extensionMode,
        requestJustification: 'StructAI 구조 엔지니어링 컨텍스트 기반 응답/평가 수행'
      },
      token
    );

    return await libResult.result;
  };

  const participant = vscode.chat.createChatParticipant(PARTICIPANT_ID, handler);
  participant.iconPath = vscode.Uri.joinPath(context.extensionUri, 'media', 'icons', 'structai.svg');

  // (선택) 후속 질문 추천
  participant.followupProvider = {
    provideFollowups(_result: any) {
      return [
        { label: '프로젝트 파일(PDF/도면/모델) 임포트 방법 안내', prompt: '@struct /import PDF·CAD·모델 파일을 어떻게 임포트해?' },
        { label: '도면 ↔ 해석모델 자동 매핑 시작', prompt: '@struct /map 자동 매핑 규칙을 제안해줘' },
        { label: '부재 안전율(D/C) 리포트 생성', prompt: '@struct /report 부재별 D/C ratio 표로 정리해줘' }
      ] satisfies vscode.ChatFollowup[];
    }
  };

  context.subscriptions.push(participant);
}

function buildStructSystemPrompt(): string {
  return [
    '당신은 “StructAI”이며 건축구조/구조해석/기준(KDS/사내기준 등) 기반 검토를 수행하는 전문 보조자다.',
    '',
    '## 운영 원칙',
    '1) 근거 우선: 결과/판단에는 항상 근거(문서, 도면, 해석결과, 기준 조항)를 제시한다.',
    '2) 불충분 정보 표시: 하중조합/단위/재료강도/단면/경계조건/모델링 가정이 누락되면 추정하지 말고 “필요 정보”를 먼저 나열한다.',
    '3) 단일 메모리: 프로젝트에 임포트된 CAD/PDF/MD/해석모델/결과를 “하나의 메모리”로 취급한다.',
    '4) 도구 우선: 아래 MCP 도구가 있으면 적극 사용한다(특히 검색/임포트/결과조회/안전율 계산).',
    '',
    '## 사용 가능한 대표 MCP 도구(예시)',
    '- structai_import_files: 파일 임포트/인덱싱',
    '- structai_search_knowledge: 기준/문서/도면 텍스트 검색',
    '- structai_get_project_summary: 현재 메모리 상태 요약',
    '- structai_run_safety_checks: 부재/요소별 안전성 평가',
    '- structai_get_check_results: 최근 평가 결과 조회',
    '- structai_upsert_mappings: CAD↔모델 매핑 저장',
    '',
    '## 답변 형식(권장)',
    '- (1) 해석/검토 범위 요약',
    '- (2) 사용한 입력/가정(누락 시 필요한 정보 질문)',
    '- (3) 계산/검토 결과(표 형태 가능)',
    '- (4) 기준/문서 근거(가능하면 조항/페이지/출처)',
    '- (5) 다음 액션(모델 보정, 추가 하중/조합, 도면-모델 매핑 개선 등)',
    '',
    '모든 답변은 한국어로 작성한다.'
  ].join('\n');
}

3) Python MCP 서버 골격 (Cursor/VS Code/Claude 등에서 재사용 가능한 “도메인 도구 서버”)

핵심 포인트

VS Code는 MCP stdio/http를 지원하고

Python 공식 SDK(FastMCP)는 @mcp.tool() 형태로 도구를 정의하고 mcp.run()으로 실행합니다.

여기서는 SQLite 기반 단일 메모리(DB) + “임포트/검색/매핑/검토” 도구만 먼저 만듭니다.

3-1) server/requirements.txt
mcp
pydantic


(PDF 텍스트 추출/ DXF 파싱/임베딩은 이후 단계에서 추가 추천: pypdf, pdfplumber, ezdxf, sentence-transformers 등)

3-2) server/structai_mcp_server.py
# server/structai_mcp_server.py
from __future__ import annotations

import hashlib
import os
import sqlite3
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Optional

from mcp.server.fastmcp import FastMCP

# -----------------------------
# Config
# -----------------------------
THIS_DIR = Path(__file__).resolve().parent
SCHEMA_PATH = THIS_DIR / "schema.sql"

def _default_db_path() -> Path:
    # 워크스페이스 루트는 VS Code가 Roots로 제공하지만,
    # 여기선 env로 받거나 현재 작업 디렉토리 기준으로 생성.
    env = os.environ.get("STRUCTAI_DB_PATH")
    if env:
        return Path(env).expanduser().resolve()
    return (Path.cwd() / ".structai" / "structai.db").resolve()

def _ensure_db(db_path: Path) -> None:
    db_path.parent.mkdir(parents=True, exist_ok=True)
    first_time = not db_path.exists()
    conn = sqlite3.connect(db_path)
    try:
        if first_time:
            schema_sql = SCHEMA_PATH.read_text(encoding="utf-8")
            conn.executescript(schema_sql)
            conn.commit()
    finally:
        conn.close()

def _sha256_file(p: Path) -> str:
    h = hashlib.sha256()
    with p.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()

def _now_ms() -> int:
    return int(time.time() * 1000)

# -----------------------------
# MCP server
# -----------------------------
mcp = FastMCP("StructAI MCP Server")

DB_PATH = _default_db_path()
_ensure_db(DB_PATH)

# -----------------------------
# Data models (optional)
# -----------------------------
@dataclass
class SearchHit:
    chunk_id: int
    artifact_id: str
    uri: str
    snippet: str
    score: float

# -----------------------------
# Tools
# -----------------------------
@mcp.tool()
def structai_get_project_summary() -> dict[str, Any]:
    """Return counts of artifacts/chunks/mappings/checks in the project DB."""
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    try:
        def q(sql: str) -> int:
            row = conn.execute(sql).fetchone()
            return int(row[0]) if row else 0

        return {
            "db_path": str(DB_PATH),
            "artifacts": q("SELECT COUNT(*) FROM artifacts;"),
            "doc_chunks": q("SELECT COUNT(*) FROM doc_chunks;"),
            "mappings": q("SELECT COUNT(*) FROM mappings;"),
            "checks": q("SELECT COUNT(*) FROM safety_checks;"),
            "updated_at_ms": _now_ms(),
        }
    finally:
        conn.close()

@mcp.tool()
def structai_import_files(paths: list[str]) -> dict[str, Any]:
    """
    Import files (PDF/MD/DXF/etc) into unified memory DB.
    Current skeleton:
      - stores file metadata in artifacts
      - stores naive text chunks for text-like files (md/txt)
      - PDF/DXF parsing is stubbed (extend later)
    """
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    imported = []
    skipped = []
    errors = []

    try:
        for raw in paths:
            try:
                p = Path(raw).expanduser().resolve()
                if not p.exists():
                    errors.append({"path": raw, "error": "not_found"})
                    continue

                sha = _sha256_file(p)
                uri = p.as_uri()
                ext = p.suffix.lower().lstrip(".")
                size = p.stat().st_size

                # Deduplicate by sha256
                row = conn.execute("SELECT artifact_id FROM artifacts WHERE sha256 = ?", (sha,)).fetchone()
                if row:
                    skipped.append({"path": str(p), "reason": "already_imported", "artifact_id": row["artifact_id"]})
                    continue

                artifact_id = hashlib.md5((sha + uri).encode("utf-8")).hexdigest()

                conn.execute(
                    """
                    INSERT INTO artifacts(artifact_id, uri, file_name, file_ext, sha256, bytes, created_at_ms, metadata_json)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    """,
                    (artifact_id, uri, p.name, ext, sha, size, _now_ms(), "{}"),
                )

                # naive ingestion for md/txt
                if ext in ("md", "txt"):
                    text = p.read_text(encoding="utf-8", errors="ignore")
                    chunks = _chunk_text(text, max_chars=1500, overlap=200)
                    for i, c in enumerate(chunks):
                        conn.execute(
                            """
                            INSERT INTO doc_chunks(artifact_id, chunk_index, content, page_start, page_end, metadata_json)
                            VALUES (?, ?, ?, NULL, NULL, ?)
                            """,
                            (artifact_id, i, c, "{}"),
                        )
                else:
                    # PDF/DXF 등은 이후 단계에서 파서/추출기 추가
                    pass

                imported.append({"path": str(p), "artifact_id": artifact_id, "uri": uri, "ext": ext})
            except Exception as e:
                errors.append({"path": raw, "error": repr(e)})

        conn.commit()
        return {
            "imported": imported,
            "skipped": skipped,
            "errors": errors,
            "count_imported": len(imported),
            "count_skipped": len(skipped),
            "count_errors": len(errors),
        }
    finally:
        conn.close()

@mcp.tool()
def structai_search_knowledge(query: str, top_k: int = 5) -> dict[str, Any]:
    """
    Search imported doc chunks by LIKE (skeleton).
    Upgrade path:
      - BM25 FTS5
      - vector embeddings + ANN
      - PDF page-aware citations
    """
    q = query.strip()
    if not q:
        return {"hits": []}

    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    try:
        rows = conn.execute(
            """
            SELECT c.chunk_id, c.artifact_id, a.uri, c.content
            FROM doc_chunks c
            JOIN artifacts a ON a.artifact_id = c.artifact_id
            WHERE c.content LIKE ?
            ORDER BY c.chunk_id DESC
            LIMIT ?
            """,
            (f"%{q}%", int(top_k)),
        ).fetchall()

        hits: list[dict[str, Any]] = []
        for r in rows:
            content = r["content"] or ""
            snippet = _make_snippet(content, q, radius=120)
            hits.append(
                {
                    "chunk_id": int(r["chunk_id"]),
                    "artifact_id": r["artifact_id"],
                    "uri": r["uri"],
                    "snippet": snippet,
                    "score": 0.0,  # placeholder
                }
            )
        return {"hits": hits}
    finally:
        conn.close()

@mcp.tool()
def structai_upsert_mappings(mappings: list[dict[str, Any]]) -> dict[str, Any]:
    """
    Store CAD↔Model↔Docs mapping entries.
    Expected mapping fields (flexible):
      - source_type, source_ref, target_type, target_ref, confidence, notes
    """
    conn = sqlite3.connect(DB_PATH)
    try:
        upserted = 0
        for m in mappings:
            source_type = str(m.get("source_type", "unknown"))
            source_ref = str(m.get("source_ref", ""))
            target_type = str(m.get("target_type", "unknown"))
            target_ref = str(m.get("target_ref", ""))
            confidence = float(m.get("confidence", 0.5))
            notes = str(m.get("notes", ""))

            if not source_ref or not target_ref:
                continue

            mapping_id = hashlib.md5(f"{source_type}:{source_ref}->{target_type}:{target_ref}".encode("utf-8")).hexdigest()
            conn.execute(
                """
                INSERT INTO mappings(mapping_id, source_type, source_ref, target_type, target_ref, confidence, notes, updated_at_ms)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT(mapping_id) DO UPDATE SET
                  confidence=excluded.confidence,
                  notes=excluded.notes,
                  updated_at_ms=excluded.updated_at_ms
                """,
                (mapping_id, source_type, source_ref, target_type, target_ref, confidence, notes, _now_ms()),
            )
            upserted += 1

        conn.commit()
        return {"upserted": upserted}
    finally:
        conn.close()

@mcp.tool()
def structai_run_safety_checks(component_ids: list[str], combo: str = "ULS") -> dict[str, Any]:
    """
    Skeleton safety check tool.
    Real implementation should:
      - pull FE results (forces, moments, displacements)
      - apply design code rules
      - compute demand/capacity and store results
    """
    conn = sqlite3.connect(DB_PATH)
    try:
        results = []
        for cid in component_ids:
            # Placeholder logic:
            demand = 1.0
            capacity = 1.0
            ratio = demand / capacity if capacity else None
            status = "PASS" if ratio is not None and ratio <= 1.0 else "FAIL"

            check_id = hashlib.md5(f"{cid}:{combo}:{_now_ms()}".encode("utf-8")).hexdigest()
            conn.execute(
                """
                INSERT INTO safety_checks(check_id, component_id, combo, demand, capacity, ratio, status, details_json, created_at_ms)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (check_id, cid, combo, demand, capacity, ratio, status, "{}", _now_ms()),
            )
            results.append(
                {
                    "check_id": check_id,
                    "component_id": cid,
                    "combo": combo,
                    "demand": demand,
                    "capacity": capacity,
                    "ratio": ratio,
                    "status": status,
                }
            )

        conn.commit()
        return {"results": results}
    finally:
        conn.close()

@mcp.tool()
def structai_get_check_results(limit: int = 50) -> dict[str, Any]:
    """Fetch latest safety check results."""
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    try:
        rows = conn.execute(
            """
            SELECT check_id, component_id, combo, demand, capacity, ratio, status, created_at_ms
            FROM safety_checks
            ORDER BY created_at_ms DESC
            LIMIT ?
            """,
            (int(limit),),
        ).fetchall()
        return {"checks": [dict(r) for r in rows]}
    finally:
        conn.close()

# -----------------------------
# Helpers
# -----------------------------
def _chunk_text(text: str, max_chars: int = 1500, overlap: int = 200) -> list[str]:
    t = text.strip()
    if not t:
        return []
    chunks: list[str] = []
    i = 0
    while i < len(t):
        end = min(len(t), i + max_chars)
        chunks.append(t[i:end])
        if end == len(t):
            break
        i = max(0, end - overlap)
    return chunks

def _make_snippet(content: str, q: str, radius: int = 120) -> str:
    idx = content.lower().find(q.lower())
    if idx < 0:
        return content[: min(len(content), radius * 2)]
    start = max(0, idx - radius)
    end = min(len(content), idx + len(q) + radius)
    return content[start:end]

if __name__ == "__main__":
    # 기본은 stdio 실행(클라이언트가 stdin/stdout으로 통신)
    # FastMCP는 mcp.run()으로 실행 가능 
    mcp.run()

(보너스) VS Code 확장에서 MCP 서버 “자동 등록” 코드 (필수 연결고리)

VS Code는 확장에서 mcpServerDefinitionProviders를 선언하고,
vscode.lm.registerMcpServerDefinitionProvider(...)로 실제 서버 정의를 제공해 자동 등록할 수 있습니다.

src/mcp/provider.ts
// src/mcp/provider.ts
import * as path from 'path';
import * as vscode from 'vscode';

export function registerStructMcpProvider(context: vscode.ExtensionContext) {
  const didChange = new vscode.EventEmitter<void>();

  const provider: any = {
    // docs에서는 onDidChangeMcpServerDefinitions 라는 이름으로 소개됩니다. 
    onDidChangeMcpServerDefinitions: didChange.event,
    provideMcpServerDefinitions: async () => {
      const pythonPath = vscode.workspace.getConfiguration().get<string>('structai.pythonPath') || 'python';
      const configuredDbPath = vscode.workspace.getConfiguration().get<string>('structai.dbPath') || '';

      const serverScript = vscode.Uri.joinPath(context.extensionUri, 'server', 'structai_mcp_server.py');
      const cwd = vscode.workspace.workspaceFolders?.[0]?.uri ?? vscode.Uri.file(process.cwd());

      const env: Record<string, string | number | null> = {
        STRUCTAI_DB_PATH: configuredDbPath || path.join(cwd.fsPath, '.structai', 'structai.db')
      };

      // NOTE: vscode.d.ts의 constructor 시그니처가 버전에 따라 다를 수 있어 any 캐스팅으로 안전 처리
      const def = new (vscode as any).McpStdioServerDefinition({
        label: 'StructAI Local MCP',
        command: pythonPath,
        args: ['-u', serverScript.fsPath],
        cwd,
        env,
        version: '0.0.1'
      });

      return [def];
    },
    resolveMcpServerDefinition: async (server: any) => {
      // 필요 시 여기서 사용자 입력(인증/경로확인 등) 수행 가능 
      return server;
    }
  };

  context.subscriptions.push(vscode.lm.registerMcpServerDefinitionProvider('structaiMcpProvider', provider));
  context.subscriptions.push(didChange);
}

src/extension.ts
// src/extension.ts
import * as vscode from 'vscode';
import { registerStructChatParticipant } from './chat/participant';
import { registerStructMcpProvider } from './mcp/provider';
import { registerMappingView } from './views/mappingView';

export function activate(context: vscode.ExtensionContext) {
  registerStructMcpProvider(context);
  registerStructChatParticipant(context);
  registerMappingView(context);

  context.subscriptions.push(
    vscode.commands.registerCommand('structai.openPanel', async () => {
      // 패널을 오른쪽으로 옮기는 명령은 사용자 환경에 따라 다를 수 있어,
      // 일단 panel container를 보여주는 흐름 위주로 처리
      await vscode.commands.executeCommand('workbench.view.extension.structai.panel');
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand('structai.openMapping', async () => {
      await vscode.commands.executeCommand('workbench.view.extension.structai.panel');
      await vscode.commands.executeCommand('structai.mapping.focus');
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand('structai.openMemory', async () => {
      await vscode.commands.executeCommand('workbench.view.extension.structai.panel');
      await vscode.commands.executeCommand('structai.memory.focus');
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand('structai.openResults', async () => {
      await vscode.commands.executeCommand('workbench.view.extension.structai.panel');
      await vscode.commands.executeCommand('structai.results.focus');
    })
  );
}

export function deactivate() {}

4) server/schema.sql (단일 메모리 DB 스키마)

“문서/도면/모델/결과/검토”를 하나의 메모리로 합치기 위한 최소 스키마입니다.
(추후 FTS5, 벡터 인덱스, 요소/노드 상세 테이블 확장 가능)

-- server/schema.sql
PRAGMA foreign_keys = ON;

-- --- Meta
CREATE TABLE IF NOT EXISTS meta (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL
);

INSERT OR IGNORE INTO meta(key, value) VALUES ('schema_version', '0.0.1');

-- --- Artifacts: imported files (PDF/MD/DXF/...)
CREATE TABLE IF NOT EXISTS artifacts (
  artifact_id TEXT PRIMARY KEY,
  uri TEXT NOT NULL,
  file_name TEXT NOT NULL,
  file_ext TEXT,
  sha256 TEXT NOT NULL,
  bytes INTEGER NOT NULL,
  created_at_ms INTEGER NOT NULL,
  metadata_json TEXT NOT NULL DEFAULT '{}'
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_artifacts_sha256 ON artifacts(sha256);
CREATE INDEX IF NOT EXISTS idx_artifacts_created ON artifacts(created_at_ms);

-- --- Document chunks
CREATE TABLE IF NOT EXISTS doc_chunks (
  chunk_id INTEGER PRIMARY KEY AUTOINCREMENT,
  artifact_id TEXT NOT NULL,
  chunk_index INTEGER NOT NULL,
  content TEXT NOT NULL,
  page_start INTEGER NULL,
  page_end INTEGER NULL,
  metadata_json TEXT NOT NULL DEFAULT '{}',
  FOREIGN KEY (artifact_id) REFERENCES artifacts(artifact_id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_doc_chunks_artifact ON doc_chunks(artifact_id);
CREATE INDEX IF NOT EXISTS idx_doc_chunks_chunk_index ON doc_chunks(artifact_id, chunk_index);

-- --- Mappings: CAD ↔ Model ↔ Docs
CREATE TABLE IF NOT EXISTS mappings (
  mapping_id TEXT PRIMARY KEY,
  source_type TEXT NOT NULL,   -- cad_layer | cad_entity | pdf_table | md_section | manual | ...
  source_ref TEXT NOT NULL,    -- e.g. "A-WALL", "B12", "pdf:artifact#page:12"
  target_type TEXT NOT NULL,   -- member | element | load | combo | material | ...
  target_ref TEXT NOT NULL,    -- e.g. "BEAM-B12", "ELEM:1234"
  confidence REAL NOT NULL DEFAULT 0.5,
  notes TEXT NOT NULL DEFAULT '',
  updated_at_ms INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_mappings_source ON mappings(source_type, source_ref);
CREATE INDEX IF NOT EXISTS idx_mappings_target ON mappings(target_type, target_ref);

-- --- Safety checks
CREATE TABLE IF NOT EXISTS safety_checks (
  check_id TEXT PRIMARY KEY,
  component_id TEXT NOT NULL,     -- member/element id
  combo TEXT NOT NULL,            -- ULS/SLS or named load combo
  demand REAL,
  capacity REAL,
  ratio REAL,
  status TEXT NOT NULL,           -- PASS/FAIL/WARN/NA
  details_json TEXT NOT NULL DEFAULT '{}',
  created_at_ms INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_checks_created ON safety_checks(created_at_ms);
CREATE INDEX IF NOT EXISTS idx_checks_component ON safety_checks(component_id);

5) “매핑 Webview UI” 와이어프레임 + 최소 코드 골격
5-1) UX 와이어프레임(텍스트)
┌────────────────────────────────────────────────────────────────────────────┐
│ StructAI Mapping                                                           │
│ Project: <workspace>   Active Model: <model>   Units: kN-m   Status: Ready │
├───────────────┬───────────────────────────────────┬────────────────────────┤
│ [Sources]     │ [Mappings]                         │ [Details / Actions]    │
│ Tabs:         │ Search: [___________]  (Auto-map)  │ Selected Mapping       │
│  - CAD        │ ┌─────────┬──────────┬───────────┐ │ - Source: ...          │
│  - PDF        │ │ Source  │ Target   │ Conf/Note  │ │ - Target: ...          │
│  - MD         │ ├─────────┼──────────┼───────────┤ │ - Confidence slider     │
│  - FE Model   │ │ ...     │ ...      │ ...       │ │ - Validate / Save       │
│               │ └─────────┴──────────┴───────────┘ │ - Open artifact/model   │
│ CAD: layers   │ (Add row) (Delete) (Export)        │ - Generate checks       │
│ PDF: docs     │                                   │ - Cite code clauses     │
│ FE: members   │                                   │                          │
├───────────────┴───────────────────────────────────┴────────────────────────┤
│ Footer: Auto-map progress / warnings / suggestions                          │
└────────────────────────────────────────────────────────────────────────────┘

5-2) src/views/mappingView.ts (WebviewViewProvider)
// src/views/mappingView.ts
import * as vscode from 'vscode';

export function registerMappingView(context: vscode.ExtensionContext) {
  const provider = new MappingViewProvider(context.extensionUri);
  context.subscriptions.push(
    vscode.window.registerWebviewViewProvider('structai.mapping', provider, {
      webviewOptions: { retainContextWhenHidden: true }
    })
  );
}

class MappingViewProvider implements vscode.WebviewViewProvider {
  constructor(private readonly extensionUri: vscode.Uri) {}

  resolveWebviewView(view: vscode.WebviewView): void | Thenable<void> {
    view.webview.options = {
      enableScripts: true,
      localResourceRoots: [
        vscode.Uri.joinPath(this.extensionUri, 'media')
      ]
    };

    const cssUri = view.webview.asWebviewUri(vscode.Uri.joinPath(this.extensionUri, 'media', 'mapping', 'main.css'));
    const jsUri = view.webview.asWebviewUri(vscode.Uri.joinPath(this.extensionUri, 'media', 'mapping', 'main.js'));

    view.webview.html = getHtml(cssUri, jsUri);

    view.webview.onDidReceiveMessage(async (msg) => {
      switch (msg?.type) {
        case 'requestState': {
          // TODO: MCP에서 mappings/artifacts 요약을 받아서 내려주기
          view.webview.postMessage({
            type: 'state',
            state: {
              sources: { cad: [], pdf: [], md: [], model: [] },
              mappings: []
            }
          });
          break;
        }
        case 'saveMappings': {
          // TODO: MCP tool structai_upsert_mappings 호출로 저장
          vscode.window.showInformationMessage(`Mapping ${msg?.mappings?.length ?? 0}개 저장 요청(스켈레톤)`);
          break;
        }
        default:
          break;
      }
    });
  }
}

function getHtml(cssUri: vscode.Uri, jsUri: vscode.Uri): string {
  return /* html */ `
<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; style-src ${'${'}webview.cspSource${'}'}; script-src ${'${'}webview.cspSource${'}'};"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="${cssUri}">
  <title>StructAI Mapping</title>
</head>
<body>
  <header class="header">
    <div class="title">StructAI Mapping</div>
    <div class="subtitle">CAD ↔ Model ↔ Docs 통합 매핑</div>
  </header>

  <main class="grid">
    <section class="pane pane-left">
      <div class="pane-title">Sources</div>
      <div class="tabs">
        <button data-tab="cad" class="tab active">CAD</button>
        <button data-tab="pdf" class="tab">PDF</button>
        <button data-tab="md" class="tab">MD</button>
        <button data-tab="model" class="tab">FE Model</button>
      </div>
      <div id="sources" class="list">(loading...)</div>
    </section>

    <section class="pane pane-center">
      <div class="pane-title">Mappings</div>
      <div class="toolbar">
        <input id="search" placeholder="Search source/target..." />
        <button id="autoMap">Auto-map</button>
        <button id="save">Save</button>
      </div>
      <div id="mappings" class="table">(loading...)</div>
    </section>

    <section class="pane pane-right">
      <div class="pane-title">Details</div>
      <div id="details" class="details">(select a mapping)</div>
      <div class="actions">
        <button id="validate">Validate</button>
        <button id="open">Open</button>
        <button id="check">Run Checks</button>
      </div>
    </section>
  </main>

  <footer class="footer" id="footer">Ready</footer>

  <script src="${jsUri}"></script>
</body>
</html>`;
}

5-3) media/mapping/main.css
/* media/mapping/main.css */
:root {
  --gap: 10px;
  --border: 1px solid var(--vscode-panel-border);
}

body {
  padding: 0;
  margin: 0;
  font-family: var(--vscode-font-family);
  color: var(--vscode-foreground);
  background: var(--vscode-editor-background);
}

.header {
  padding: 10px 12px;
  border-bottom: var(--border);
}

.title {
  font-weight: 700;
}

.subtitle {
  opacity: 0.8;
  margin-top: 2px;
  font-size: 12px;
}

.grid {
  display: grid;
  grid-template-columns: 1fr 1.4fr 1fr;
  gap: var(--gap);
  padding: var(--gap);
}

.pane {
  border: var(--border);
  border-radius: 6px;
  overflow: hidden;
  background: var(--vscode-sideBar-background);
}

.pane-title {
  padding: 8px 10px;
  border-bottom: var(--border);
  background: var(--vscode-sideBarSectionHeader-background);
  font-weight: 600;
}

.tabs {
  display: flex;
  gap: 6px;
  padding: 8px 10px;
  border-bottom: var(--border);
}

.tab {
  font-size: 12px;
}

.list, .table, .details {
  padding: 10px;
  min-height: 240px;
  font-size: 12px;
  white-space: pre-wrap;
}

.toolbar {
  display: flex;
  gap: 6px;
  padding: 8px 10px;
  border-bottom: var(--border);
}

.toolbar input {
  flex: 1;
}

.actions {
  display: flex;
  gap: 6px;
  padding: 10px;
  border-top: var(--border);
}

.footer {
  border-top: var(--border);
  padding: 8px 12px;
  opacity: 0.8;
  font-size: 12px;
}

5-4) media/mapping/main.js
// media/mapping/main.js
(function () {
  const vscode = acquireVsCodeApi();

  const sourcesEl = document.getElementById('sources');
  const mappingsEl = document.getElementById('mappings');
  const detailsEl = document.getElementById('details');
  const footerEl = document.getElementById('footer');

  const saveBtn = document.getElementById('save');
  const autoMapBtn = document.getElementById('autoMap');

  let state = { sources: { cad: [], pdf: [], md: [], model: [] }, mappings: [] };

  function render() {
    sourcesEl.textContent = JSON.stringify(state.sources, null, 2);
    mappingsEl.textContent = JSON.stringify(state.mappings, null, 2);
    detailsEl.textContent = '(select a mapping - skeleton)';
  }

  window.addEventListener('message', (event) => {
    const msg = event.data;
    if (msg?.type === 'state') {
      state = msg.state || state;
      footerEl.textContent = 'State loaded';
      render();
    }
  });

  saveBtn.addEventListener('click', () => {
    vscode.postMessage({ type: 'saveMappings', mappings: state.mappings });
    footerEl.textContent = 'Save requested';
  });

  autoMapBtn.addEventListener('click', () => {
    // TODO: MCP tool로 자동매핑 실행
    footerEl.textContent = 'Auto-map (TODO)';
  });

  // init
  vscode.postMessage({ type: 'requestState' });
})();

다음 단계(바로 이어서 개발할 “순서”)

지금 상태는 **“플러그인(채팅) + MCP 서버(도구) + 단일 DB + 매핑 UI”**의 최소 골격입니다.
다음 단계는 보통 아래 순서가 가장 안전합니다:

PDF/MD 인덱싱 강화: PDF 텍스트 추출 + 페이지/표/그림 메타 저장 → structai_search_knowledge에 페이지 단위 근거 반환

CAD 파이프라인 확정: DWG 직접 파싱 대신 “DXF 변환 + 레이어/블록/텍스트 추출”부터 안정화

FEA 연동 경로 선택: (a) OpenSees/CalculiX 등 오픈 솔버, (b) 상용 솔버는 “결과 export(JSON/CSV)”로 간접 연동

구조기준 문서 통합: 기준 PDF를 “조항 단위 chunk + id(조항번호) + 인용 포맷”으로 정규화

안전성 평가 엔진: check type(휨/전단/축력/좌굴/변위/진동 등)별로 demand/capacity 계산을 모듈화 + DB에 저장

원하면, 위 골격을 그대로 기반으로 (A) PDF 페이지 인용까지 되는 인덱서(FTS5 포함) 또는 (B) DXF 레이어/텍스트 기반 자동 매핑 룰 엔진을 “다음 순서”로 바로 붙여서 이어가겠습니다.
