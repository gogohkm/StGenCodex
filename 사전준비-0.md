아키텍처를 “Cursor처럼 오른쪽 대화창 + 하나의 메모리”로 만들면서도, CAD/PDF/MD/해석모델/해석결과/구조기준까지 한 번에 다루려면 핵심은 2가지예요.

UI는 VS Code(또는 VS Code 기반) 안에 깊게 붙이고

AI는 ‘대화’가 아니라 ‘도구(스킬) 호출 + 프로젝트 메모리’ 중심으로 설계하는 것

아래는 제가 권장하는 구현 전략(현실적으로 개발/배포 가능한 방향)과, 그에 맞춘 구체적인 구성안입니다.

1) “VS Code처럼” 만드는 방법 선택지 3가지
A안) VS Code 확장(Extension)으로 시작 (가장 추천)

장점

VS Code가 제공하는 UI 레이아웃(사이드바/패널/탭/에디터) 그대로 활용

Chat Participant API로 VS Code의 채팅 경험에 “구조 엔지니어 참가자(@mention)”를 추가 가능 
Visual Studio Code

Language Model Tools API / MCP로 “클로드 스킬 같은 도구 호출”을 자연스럽게 구현 가능 
Visual Studio Code
+2
Visual Studio Code
+2

단점

VS Code 자체를 바꾸는 수준(최상단 메뉴/코어 행동)을 완전히 장악하긴 어려움

CAD/FEA처럼 무거운 UI는 Webview/Custom Editor로 해결해야 함(하지만 충분히 가능)

당장 MVP를 만들려면 A안이 제일 빠르고, 제품화도 안정적입니다.

B안) Code-OSS 기반 “커스텀 VS Code 배포판” (확장판)

장점

Cursor 같은 “AI-native IDE”처럼 디폴트 UI/기능을 더 강하게 커스터마이즈 가능

단점(중요)

VS Code는 Code-OSS를 기반으로 하지만, 배포판/마켓플레이스/라이선싱 이슈가 생길 수 있음 
Visual Studio Code

추천 타이밍

Extension으로 PMF(제품 적합) 확인 후, “우리만의 IDE”가 반드시 필요해졌을 때

C안) Electron + Monaco Editor로 자체 IDE 제작

장점: 모든 걸 내 맘대로

단점: VS Code 생태계(확장/워크스페이스 경험)를 다시 만들어야 해서 비용이 큼

2) UI/UX 설계: “Cursor AI처럼 오른쪽 채팅 + 구조 도구 패널”

VS Code에서 구현 방법은 2가지가 있어요.

방법 1) VS Code의 Chat Participant(@구조AI) 로 통합

사용자가 채팅에서 @struct 같은 참가자를 호출해서 도메인 특화 에이전트를 쓰는 방식

참가자가 “엔드투엔드 흐름(도구 호출, 파일 열기, 결과 표시 등)”을 오케스트레이션할 수 있다는 게 핵심 
Visual Studio Code

구조 엔지니어링 작업은 ‘대화’보다 ‘행동(도구 실행)’이 많기 때문에 이게 잘 맞습니다.

방법 2) 오른쪽에 Webview View로 “전용 채팅창” 만들기

VS Code는 Webview를 사이드바/패널에 배치할 수 있고(=webview view), 복잡한 UI를 만들 수 있습니다 
Visual Studio Code
+1

“Cursor처럼 오른쪽에 고정된 대화창 + 히스토리 + 도구 버튼”을 완전히 동일하게 만들 수 있음

추천: 초기에는 Chat Participant를 메인으로 두고,
“도면/모델 선택 상태, 체크리스트, 결과표, 스냅샷” 같은 전문 UI는 Webview로 보강하는 하이브리드.

3) 핵심 아키텍처: “하나의 메모리”를 만드는 방법

여기서 말하는 “메모리”는 단순 채팅 히스토리가 아니라:

프로젝트의 구조 시스템(부재/재료/하중/해석조건/조합/결과/판정)

기준 문서의 조항/표/식/적용 조건

도면/모델에서 추출된 엔티티(기둥 C1, 보 B12 등)와 위치/단면

대화로 합의한 가정(예: 콘크리트 강도, 지진구역, 중요도 계수, 설계기준 버전)

이걸 한 공간에 “구조화 + 검색 + 근거추적” 가능하게 넣어야 합니다.

제가 권장하는 메모리 모델: Project Knowledge Graph + Vector RAG

구조화 저장(“사실/객체”)

Member(부재), Section, Material, LoadCase, Combo, Result(내력/응력비), Check(기준별 판정)

DB: Postgres(+JSONB) 또는 SQLite(단일 프로젝트 파일로도 가능)

비정형 저장(“문서/근거”)

PDF/MD/기준 문서/리포트/회의 메모

벡터 DB(pgvector 등)로 RAG 인덱싱

연결(그래프)

“B12 보” ↔ “도면의 해당 객체” ↔ “해석모델 요소 ID” ↔ “조합별 내력” ↔ “기준 조항” ↔ “판정 리포트”

이 연결이 있어야 대화로 ‘왜 이런 결론이 나왔는지’ 추적이 됩니다.

4) 데이터 타입별 처리 파이프라인 (CAD/PDF/MD/해석모델/결과)
(1) PDF / MD / 기준 문서

PDF는 PDF.js로 VS Code Webview에서 렌더링/하이라이트/페이지 링크 구현 가능 
mozilla.github.io

텍스트 추출 + 구조화(목차/조항/표/식/그림 캡션) + chunking + 임베딩

기준 문서는 버전과 관할(예: KDS/ACI/AISC/Eurocode 등) 개념이 필수

결과 응답은 항상 “조항/표 번호 + 인용 위치”를 붙이도록(감사/검토 대비)

(2) CAD 도면

여기서 가장 큰 분기점이 “DWG를 어떻게 할 것인가”예요.

현실 추천: IFC/DXF 우선 지원

IFC는 웹에서 Three.js 기반으로 처리 가능한 오픈 생태계가 좋아요. 예: web-ifc-viewer는 IFC를 Three.js geometry로 만들고 치수/클리핑/2D 플랜 등 BIM 도구 기능을 제공합니다 
GitHub

DWG 직접 지원은 라이선스/배포 이슈가 큼

Open Design Alliance(ODA) SDK는 “연간 구독” 형태이고, 구독 종료 시 배포 권리 등에 제약이 명시됩니다 
Open Design Alliance

따라서 선택지는:

DWG → DXF/IFC 변환을 사전 요구(사용자 워크플로우)

서버/로컬 변환기를 묶되 라이선스를 명확히 처리

ODA를 공식 탑재(비용/계약 전제)

도면에서 AI가 해야 하는 일은 보통 3단계입니다.

요소 추출: 레이어/블록/치수/문자에서 부재/그리드/레벨/단면표를 뽑기

구조 모델 매핑: “도면 객체 ↔ 구조부재 객체” 연결

검증/보정 UI: AI가 100% 맞출 수 없으니, 사용자가 클릭으로 매핑을 고치게 해야 함

즉, “AI가 읽는다”보다 “AI가 후보를 만들고, UI가 확정” 구조가 훨씬 실전적입니다.

(3) 유한요소해석(FEA) 모델/결과

여기서 중요한 건 “LLM이 해석을 하는 게 아니라, 해석 엔진을 조종하고 결과를 해석한다”입니다.

권장 구성:

해석 실행/파싱은 별도 서비스(로컬 Python 권장)

VS Code에서는:

모델 뷰어(3D)

하중/경계조건 편집

결과 플롯(변위/내력도/응력비 히트맵)

부재 선택 시 속성/결과/판정 동기화

엔진 선택지는:

오픈소스: OpenSees (비선형/지진 분야 강점) 
opensees.berkeley.edu
+1

상용 연동: SAP2000/ETABS/ANSYS/Abaqus/MIDAS 등은 API/파일 인터페이스 기반으로 “커넥터”만 제공(라이선스는 사용자 보유)

핵심은 엔진을 바꾸더라도 프로젝트 메모리 구조는 유지되도록,

ModelAdapter(입력 생성)

ResultAdapter(출력 파싱)

CheckAdapter(기준별 판정)
을 분리하는 것입니다.

5) “클로드 스킬 같은 방식”을 VS Code에서 구현하는 베스트 패턴

여기서 VS Code가 제공하는 큰 무기가 있어요:

Language Model Tools API: 확장이 “도구(함수)”를 제공하면, 에이전트가 필요할 때 호출하는 구조 
Visual Studio Code

MCP(Model Context Protocol): 외부 도구/데이터를 표준화된 방식으로 연결하는 프로토콜(오픈 표준) 
GitHub
+1

VS Code는 MCP 서버를 .vscode/mcp.json으로 프로젝트 단위로 설정할 수 있고, 관리/설치 방식도 가이드가 있습니다 
Visual Studio Code
+1

추천 구현: “도구 레이어 2단”

1단(Extension Tool): VS Code 내부 컨텍스트(열린 파일, 선택 영역, UI 상태)에 강한 도구

2단(MCP Server): 구조해석/코드체크/도면파서 같은 “무거운 도메인 엔진”을 외부 프로세스로 분리

이렇게 하면:

VS Code 안에서는 가볍게 UI/오케스트레이션

연산/파싱/인덱싱은 Python 서비스에서 안정적으로 처리

나중에 VS Code 외(웹/데스크톱)로도 재사용 가능

6) “구조 안전성 평가”를 안전하고 신뢰성 있게 만드는 설계 포인트

구조 안전성 평가는 결정론/재현성/근거추적이 생명입니다. 그래서 LLM에게 계산을 맡기면 위험해져요.

(1) 계산과 판정은 “결정론 엔진”이 담당

LLM의 역할:

어떤 체크가 필요한지 계획

필요한 입력 누락을 발견하고 질문

결과를 읽기 좋게 설명 + 근거 링크 제공

실제 수치 계산/단위/조합/판정은:

check_member(member_id, code_version, combo_id) 같은 함수가 수행

결과로 식/중간값/단위/조항/판정을 모두 반환

(2) “감사 가능한 결과물”을 기본으로

모든 체크 결과는:

입력 스냅샷(모델/하중/재료/기준버전)

결과 스냅샷(내력/응답)

기준 인용(조항, 표, 식)

최종 판정 + 경고(가정/불확실성)

를 포함해야 합니다.

(3) 도구 호출은 승인/가시성 기반

VS Code 채팅 도구는 “사용자가 어떤 도구를 쓸지 제어/승인”하는 방향으로 UX가 잡혀 있습니다. 
Visual Studio Code
+1

구조 분야는 특히:

“모델 변경” / “하중 변경” / “설계값 업데이트” 같은 행위는

항상 승인(approve) + 변경 diff를 보여주는 게 좋습니다.

7) 제가 제안하는 모듈 구성(구체)
클라이언트(VS Code Extension / TypeScript)

Chat Participant (@struct)

/import, /run, /check, /report 같은 슬래시 커맨드 제공(작업 단축) 
Visual Studio Code

Webview Views / Custom Editors

PDF 뷰어(하이라이트/인용/조항 링크) — PDF.js 
mozilla.github.io

IFC/DXF 뷰어(선택/속성 패널/치수) — web-ifc-viewer 
GitHub

해석 모델/결과 뷰어(3D + 플롯) — Three.js 기반(렌더링 레이어)

Context Collector

“현재 선택된 부재”, “열린 도면/페이지”, “현재 조합”, “최근 체크 결과”를 자동 컨텍스트로 수집

Tool Bridge

Extension Tool로 로컬 서비스 호출

또는 MCP server로 툴 노출/연결

로컬 백엔드(Python 권장)

Indexer Service: PDF/MD/CAD 파싱 + 임베딩/인덱싱

Model Service: 부재/단면/재료/하중/조합을 구조화 저장

FEA Runner: 해석 실행/모델 변환/결과 파싱

Code Check Engine: 기준별 검토(철근콘크리트/강구조/기초 등)

Report Service: 계산서/검토서 자동 생성(템플릿)

저장소

project.db(SQLite) 또는 Postgres

vector store(pgvector 등)

원본 파일/스냅샷 저장(프로젝트 폴더 내)

8) 개발 로드맵(현실적으로 “쪼개서” 성공하는 순서)
Phase 1 — “AI 대화 + 워크스페이스 기억” MVP

오른쪽 채팅(참가자 or webview)

MD/PDF 인덱싱 + 검색 + 인용

“프로젝트 메모리(가정/재료/하중 요약)” 자동 생성/업데이트

Phase 2 — 도면/모델 뷰어 최소 기능

PDF 뷰어(하이라이트)

IFC 또는 DXF 뷰어(선택/속성)

부재 리스트/속성 DB 연결(수동 매핑 UI 포함)

Phase 3 — 해석 연동(단일 엔진부터)

OpenSees 같은 엔진 or 상용 API 커넥터 1개

“모델 생성 → 실행 → 결과 파싱 → DB 적재 → 뷰어 표시” 파이프라인 완성

Phase 4 — 기준 체크(한 분야부터)

예: RC 보/기둥 휨·전단·축력 상호작용 등 “대표 체크”를 결정론 엔진으로 구현

채팅에서 /check member=B12 combo=ULS1 code=KDS-202X 같은 워크플로우

Phase 5 — 통합(진짜 ‘하나의 메모리’)

도면 객체 ↔ 해석 요소 ↔ 체크 결과 ↔ 기준 조항 연결 그래프 완성

결과 보고서 자동 생성 + 변경 이력(스냅샷) 고도화

9) 마지막으로: 이 제품이 “Cursor와 다르게” 성공하려면

당연히 LLM 성능도 중요하지만, 구조 분야에서는 다음이 승부처입니다.

근거 추적(도면/해석/기준 링크)

결정론 계산 엔진(재현성)

모델/도면/결과를 잇는 데이터 모델(그래프)

사용자가 실수 없이 확정할 수 있는 UI(매핑/승인/diff)

이 4개가 갖춰지면, 대화창은 “챗봇”이 아니라 프로젝트 조종석이 됩니다.

원하면 다음 단계로, 위 설계를 더 “개발 문서 수준”으로 내려서:

VS Code extension 구조(패키지 구성/Contribution points)

Chat Participant + Tool schema 설계

MCP 서버의 tool 목록(예: get_member_list, run_fea, check_rc_beam, cite_code_clause, map_drawing_entity_to_member…)

프로젝트 DB 스키마 초안(테이블/필드/ID 전략)

도면 매핑 UX(클릭-확정-검증 플로우)
까지 한 번에 제안해줄게요.