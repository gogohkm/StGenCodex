아래는 **지금까지의 전체 구상(계획 + 구현 방법 + 데이터/거버넌스/회귀/비교 체계)**을 한 문서로 묶어 **체계적으로 정리한 “통합 요약 계획서”**입니다.
(위 ZIP 안에는 이 계획에 대응하는 **초기 레포 폴더 구조 + schema.sql 통합본(v0.1.4) + server.py 통합본(도구 등록/권한/거버넌스 포함)**이 들어 있습니다.)

0. 제품 목표와 핵심 컨셉
목표

VS Code 편집기 경험(= Cursor 스타일) 그대로 가져가되, 대상 도메인을 **건축구조 데이터(CAD/PDF/MD/FEA/모델/결과/기준문서)**로 확장.

오른쪽에 **AI 대화창(Webview)**을 띄우고,

사용자가 도면/문서/해석 모델/해석 결과를 보며 질문하면

AI가 **도구 호출(MCP)**로 실제 데이터에 접근하고

**메모리(프로젝트 단위 DB + 문서 인덱스 + 맥락 스냅샷)**를 유지하면서

대화형으로 부재별 구조안전성 평가까지 이끄는 통합 툴을 만든다.

Cursor와의 차별점(당신이 정의한 핵심)

코드 중심이 아니라 구조 설계/해석/기준 중심.

다루는 데이터가

CAD 도면(DXF 등) 텍스트/표/리더/스펙

PDF/MD 기준문서(코드북)

FEA 모델/해석 결과

부재 모델링/단면 DB/설계 입력/결과

이를 하나의 메모리(프로젝트 DB)에서 연결/추적/버전관리/승인/서명까지 한다.

1. 전체 아키텍처(권장 구현 방식)
구성요소 3층 구조

VS Code Extension (UI/UX)

Activity Bar에 StructAI 컨테이너

Views:

Chat(대화)

Resolve(매핑/링크 확인·확정·롤백)

QA(체크 결과/상용 비교/회귀 테스트)

Governance(데이터셋 버전/승인/서명/권한)

MCP Server (도구 실행 계층)

Python 기반

DB(SQLite) + 파일 기반 아티팩트 관리

도구(tool) 단위로:

import/parse/resolve/design/check/compare/regression/governance 를 제공

Memory Layer (지속 메모리)

SQLite(정형 데이터): 모델, 부재, 매핑, 체크 결과, 승인, 이벤트 로그, 회귀 결과 등

(향후 확장) Vector Index(비정형 문서 검색): PDF/MD/기준문서 chunk 임베딩 → RAG

이번 “starter repo”는 2)와 3)의 **뼈대 + 검증 흐름(회귀/비교/거버넌스)**를 실제 코드로 제공하고, 1)은 extension 스켈레톤을 제공합니다.

2. 데이터 흐름(End-to-End 워크플로우)
워크플로우 A: CAD → 모델 매칭(Resolve)

DXF Import

structai_import_dxf() (현재는 아티팩트 등록만 / 실제 DXF 파서는 후킹)

CAD 텍스트/표 추출(프로덕션에서 구현)

추출 결과를 cad_specs, cad_tables, cad_table_cells에 저장

테이블 스키마 추론(표를 구조화)

structai_cad_infer_table_schemas_v2()

결과: cad_table_schemas, cad_table_row_parses

부재 토큰 ↔ 해석모델 부재 매핑 확정(Resolve panel에서)

member_mappings, token_story_maps 등으로 확정/거절

스펙 링크 확정(부재 ↔ CAD 스펙)

member_spec_links에 confirmed로 확정

워크플로우 B: 스펙 반영 → 설계입력 업데이트(롤백 가능)

structai_design_apply_specs_to_inputs()

confirmed member_spec_links를 읽어서

member_design_inputs.design_json에 section/rebar 등 반영

patch 로그(design_patch_runs, design_patch_items) 남김

필요 시 structai_design_rollback_patch()로 되돌리기

워크플로우 C: 해석 결과 Import → 체크 실행

해석 결과(Envelope) Import

structai_results_import_envelopes_json() (fixtures/CI 용으로 포함)

(선택) 간이 설계 내력 계산(샘플)

structai_design_compute_rc_beam_rect() (초기 데모용)

체크 실행

structai_check_run()

rulepack + QA profile 기반으로 ratio 계산 → PASS/WARN/FAIL/NA 저장

결과: check_runs, check_results

워크플로우 D: 상용 결과 비교(benchmark compare)

벤치마크 import(상용/공인 결과)

structai_benchmark_import()

비교 실행

structai_compare_check_run_to_benchmark()

리포트 생성(MD)

structai_compare_report_generate()

(선택) 승인/서명 플로우로 이동

워크플로우 E: 회귀(Regression) 품질 게이트

케이스마다 “도구 호출 시퀀스(steps)”를 fixture로 저장

golden(정답 지표) 생성 → CI에서 동일 결과 재현 확인

주요 도구:

structai_regression_suite_upsert

structai_regression_case_upsert

structai_regression_update_golden_suite

structai_regression_run_suite_v2

structai_regression_report_generate

python -m mcp_server.regression_cli --suite core ...

3. “하나의 메모리” 설계(지속 메모리 + 재현성)
DB가 담당하는 “기억”

어떤 도면/문서(artifact)가 언제 들어왔는지

어떤 모델(model)과 어떤 부재(model_members)가 있는지

어떤 CAD 토큰이 어떤 부재로 확정됐는지(member_mappings/token_story_maps)

어떤 CAD 스펙이 어떤 부재에 링크됐는지(member_spec_links)

어떤 설계 입력이 어떤 버전으로 적용됐는지(member_design_inputs + patch log)

어떤 체크를 어떤 QA/룰팩 버전으로 돌렸는지(check_runs.meta_json)

어떤 결과가 PASS/WARN/FAIL인지(check_results)

상용과 비교했을 때 어떤 차이가 났는지(compare_*)

회귀 테스트에서 언제 무엇이 깨졌는지(regression_*)

“Context Snapshot”(재현성 핵심)

entity_contexts에 check_run/compare_run 등에 대해

활성 dataset 버전

적용된 QA profile

actor/환경 정보
를 함께 저장
→ “이 결과가 어떤 데이터/설정으로 만들어졌는지”를 나중에 1:1로 재현 가능.

4. 거버넌스(프로젝트/권한/승인/서명/데이터셋 버전)
4.1 프로젝트/역할/권한

projects, users, roles, project_memberships, project_models

서버는 STRUCTAI_ACTOR를 actor로 사용

structai_project_dashboard()로 프로젝트 현황:

매핑 커버리지

스펙 링크 커버리지

최신 체크 요약

진행 중 승인(approval_instances)

4.2 승인 워크플로우(멀티스텝)

workflow 정의: approval_workflow_defs

프로젝트 바인딩: project_workflows

인스턴스: approval_instances

투표: approval_votes

도구:

structai_workflow_import

structai_workflow_bind_project

structai_approval_request_v2

structai_approval_vote

structai_approval_read

4.3 리포트 서명(무결성)

report_signatures에 digest와 서명 기록

도구:

structai_report_sign

structai_report_verify

샘플은 sha256 또는 hmac-sha256(환경변수 키 기반) 지원

4.4 데이터셋 버전/활성화 + 영향분석 + 알림

데이터셋(섹션 DB, 기준문서, 룰팩 등)을 dataset_defs, dataset_versions로 버전관리

활성화 이벤트: dataset_activation_events

활성화 시 impact 분석:

“최신 check_run context가 구버전을 사용한 모델”을 impacted로 판단

project_events에 알림 생성

도구:

structai_dataset_register

structai_dataset_set_active

structai_dataset_get_active_all

structai_dataset_set_active_notify

5. QA/룰팩/템플릿 운영(품질 기준의 “정의” 계층)
QA profile

어떤 체크를 켤지/끌지(check_scope)

PASS/WARN/FAIL 기준(thresholds)

예외(exceptions: 특정 부재/층/체크타입 skip 또는 treat_as)

compare/regression tolerances

도구:

structai_qa_profile_import

structai_qa_profile_set_active

structai_qa_profile_bind_model

structai_qa_profile_get_effective

rulepack

체크 정의 묶음(비율식 ratio_expr, limit/warn, citations)

checks/engine.py에서 안전한 표현식 평가(safe eval)로 ratio 계산

도구:

structai_rulepack_import

structai_rulepack_set_active

(옵션) 템플릿/코드북 기반 생성: structai_rulepack_generate_from_templates

6. VS Code UI 패널 설계(권장 상호작용)
Chat 패널

사용자 질문 → (필요 시) MCP tool 호출 → 결과 요약/근거/링크 제공

“프로젝트 메모리”를 기반으로:

최근 check_run

스펙 링크 현황

dataset 버전

승인 상태
를 항상 문맥으로 유지

Resolve 패널(클로드 스킬 같은 UX)

테이블 기반으로 Suggested/Confirmed/Rejected 리스트

클릭 시:

근거(어떤 CAD 셀/리더/거리)

미리보기(부재/층/스펙)

버튼: Confirm / Reject / Rollback Patch

대응 도구:

structai_specs_list_links

structai_specs_set_link_status

structai_design_apply_specs_to_inputs

structai_design_list_patch_runs

structai_design_rollback_patch

QA 패널

check_run 목록/상세

compare_run 목록/상세 + 리포트 링크

regression run 목록/상세 + 리포트 링크

대응 도구:

structai_check_run

structai_compare_list_runs, structai_compare_read_run

structai_regression_list_runs, structai_regression_read_run

Governance 패널

dataset 활성 버전

workflow/approval 상태

report 서명/검증

프로젝트 이벤트 feed

대응 도구:

dataset_* / workflow_* / approval_* / report_sign/verify

structai_project_dashboard

7. 구현 로드맵(순서대로 “현실적인” 개발 단계)
Phase 0 — 기반(이번 zip에 포함)

SQLite 통합 스키마(v0.1.4)

MCP tool 통합 server.py

회귀/비교/승인/서명/데이터셋 버전/컨텍스트 스냅샷 체계

VS Code extension 스켈레톤

Phase 1 — CAD/FEA 실제 연동

DXF 파서 연결:

텍스트 엔티티/리더/표 영역 추출 → cad_* 채우기

FEA 연동:

모델 부재/ID/층 정보 import

해석 결과 envelope import 자동화(포맷 표준화)

“Resolve panel”에서 확정 워크플로우 완성

Phase 2 — 기준문서/코드북 RAG + 근거 인용

PDF/MD chunking + vector store

룰팩의 citations를 codebook의 실제 조항/문단으로 링크

Chat에서 “근거 문단 + 적용 이유 + 변수 매핑” 자동 생성

Phase 3 — 조직 운영(거버넌스 강화)

권한 정책 고도화(프로젝트/모델 단위)

승인 단계 다양화(병렬 승인, 조건부 승인, 만료/재요청)

배포/감사 로그/서명키 관리

8. 레포(코드 패키지) 설명

ZIP 안 핵심 파일:

mcp_server/schema.sql

통합 DB 스키마 v0.1.4

mcp_server/server.py

Step9~Step13을 통합한 도구(tool) 모음

도구 등록(툴 레지스트리), 권한/승인/데이터셋/컨텍스트/회귀/비교 포함

mcp_server/checks/engine.py

ratio_expr 안전 평가(safe eval)

fixtures/case01/*

rulepack / members / results / design_inputs / benchmark 샘플

qa_profiles/qa_default.json, workflows/workflow_3step.json

운영 설정 예시

9. 바로 실행해보는 최소 시나리오(샘플)

DB 경로/actor 설정

export STRUCTAI_DB_PATH=./structai.sqlite
export STRUCTAI_ACTOR=you@company


파이썬에서 샘플 실행(개요)

QA profile import/activate

rulepack import/activate

members/results/design inputs import

check_run 수행

benchmark import → compare → report 생성

regression suite/case 등록 → golden 생성 → run suite

(README.md에 예시 코드 포함)

마지막으로: 무엇이 “제품 수준”으로 가려면 꼭 추가되어야 하나?

DXF 파서(표/리더/텍스트)와 좌표 기반 근거(evidence) 저장

FEA 결과/조합/엔벨로프 표준화 + 단위/방향/부호 규약 통일

KDS/ACI/AISC 등 기준에 대한 검증된 내력 산정 모듈(현재 샘플은 데모용)

문서 RAG + “조항 인용/추적” 기능(감사 대응)

원하면, 다음 단계로 **(1) DXF 파서가 출력해야 하는 최소 데이터 스펙(cad_table_cells, cad_specs, evidence_json 규격)**과 (2) Resolve 패널에서 필요한 API/UI 이벤트 흐름을 “실제 구현 체크리스트” 형태로 더 구체화해서 이어서 정리해줄게요.

좋아. 아래는 네가 요청한 대로 (1) DXF 파서가 DB에 “최소한”으로 출력해야 하는 데이터 스펙과 (2) VS Code Resolve 패널에서 필요한 API/UI 이벤트 흐름을, “실제 구현 체크리스트” 수준으로 아주 구체적으로 정리한 문서야.
(지금부터는 이 문서를 기준으로 DXF 파서/Resolve UI를 개발하면, 뒤의 설계·체크·거버넌스·회귀 파이프라인이 끊김 없이 붙는다.)

1) DXF 파서 출력 최소 데이터 스펙
1.1 목표(왜 이 최소 스펙이 필요한가)

DXF 파서의 목표는 “CAD 도면에서 구조 평가에 필요한 정보를 **근거(evidence)**와 함께 정형화해서 DB에 저장”하는 거야.
그리고 이후 단계(테이블 스키마 추론/매핑/스펙 적용/체크)가 파서 내부 로직에 의존하지 않도록, DB의 표준 포맷만 믿고 돌아가게 만드는 게 핵심이야.

2) DXF 파서가 반드시 채워야 하는 DB 엔티티(최소)

아래 3가지만 제대로 채우면 Step9~Step13의 Resolve/Check/QA가 전부 돌아가.

cad_tables / cad_table_cells

cad_specs

member_spec_links.evidence_json / token_story_maps.evidence_json에서 참고하는 근거 구조(evidence schema)

✅ “도면 전체를 완벽히 구조화”할 필요는 없어.
부재표/철근표/단면표 같은 핵심 테이블 + 주요 리더(callout) 텍스트만 먼저 정확하게.

3) 좌표/단위/식별자 표준(필수 규약)
3.1 좌표계

DXF World 좌표(일반적으로 XY 평면)를 그대로 사용

x, y는 “도면 좌표계에서의 위치”

bbox는 {xmin, ymin, xmax, ymax}

회전이 있는 텍스트는 bbox가 정확히 안 나올 수 있으니:

최소로는 insertion point(x,y) + text height + rotation을 저장해도 됨

가능하면 OBB/rotated bbox도 meta로 넣기

3.2 단위

DXF는 단위가 애매할 수 있어서 메타로 반드시 저장

cad_artifacts.meta_json.units = "mm"|"m"|"inch"|...

$INSUNITS(있으면) 기반으로 추정

없으면 프로젝트 설정/사용자 선택으로 고정

Resolve/거리 기반 매칭(distance)에서 단위가 틀리면 제안 품질이 크게 떨어진다.

3.3 엔티티 식별자(cad_entity_id)

실무에서 “근거 강조/하이라이트”가 중요해서 텍스트 엔티티 식별자는 안정적으로 남겨야 한다.

권장 2가지 중 하나:

옵션 A(권장): cad_entities 테이블 추가

cad_table_cells.cad_entity_id, cad_specs.cad_entity_id가 cad_entities를 참조

cad_entities에는 DXF handle, layer, entity_type, bbox, raw_text를 저장

Resolve UI에서 “근거 위치로 점프/강조”가 쉬움

옵션 B: cad_entity_id = “DXF handle string”

테이블 스키마가 이미 int만 받는다면: cad_entity_handle TEXT 컬럼을 추가하거나

cad_table_cells.meta_json에 handle을 넣는다

4) cad_tables / cad_table_cells 최소 스펙
4.1 cad_tables (테이블 영역)

테이블은 “표 하나”를 의미. 파서는 표의 bbox와 신뢰도를 저장해야 한다.

필수 필드(최소)

cad_artifact_id

bbox_json: {xmin,ymin,xmax,ymax}

method: "grid_lines"|"text_clusters"|"block_table"|"manual"

confidence: 0~1

meta_json: (선택) rows_est, cols_est, page/sheet, layer, rotation

예시 meta_json
{
  "sheet": "S-101",
  "layer": "TABLE",
  "rows_est": 38,
  "cols_est": 8,
  "extraction": {
    "algo": "grid_lines",
    "line_tol": 1.5,
    "text_assign": "point_in_cell"
  }
}

4.2 cad_table_cells (셀 단위 텍스트)

이게 Resolve 품질의 70%를 결정한다.

필수 필드(최소)

table_id

row_idx, col_idx (0-based 권장)

text (셀 안의 최종 텍스트: 줄바꿈/공백 정리 완료)

x, y (셀 중심 또는 텍스트 insertion point)

cad_entity_id (가능하면 텍스트 엔티티의 id/handle)

(선택) bbox_json, meta_json (text_height, rotation, merged 등)

셀 텍스트 정규화 규칙(강추)

DXF MTEXT formatting codes 제거 (\P, {\f...}, \C... 등)

연속 공백 → single space

곱하기 기호 통일: × → x

H-400×200×8×13 → H-400x200x8x13

D13@200 같은 표기 유지

병합셀 처리(최소 규칙)

병합셀은 “좌상단 셀에만 text 저장”하고 나머지는 빈 셀로 남겨도 됨

대신 meta_json.merged_span = {"rowspan":2,"colspan":3} 같은 표기를 넣으면 스키마 추론이 좋아진다.

5) cad_specs 최소 스펙(리더/주석/단면/철근/층 태그)

cad_specs는 “테이블 밖에서도 잡혀야 하는 정보(리더 텍스트, 단면 콜아웃, 층 표기 등)”를 저장한다.

필수 필드(최소)

cad_artifact_id

spec_kind (정해진 enum)

raw_text (원문)

spec_json (정규화된 구조)

x, y (spec 텍스트 위치)

confidence (0~1)

method: "leader"|"text"|"table"|"manual"

(가능하면) cad_entity_id, bbox_json, meta_json

5.1 spec_kind 권장 enum(최소)

철골:

steel_h_section

steel_box_section

steel_pipe_section

steel_channel_section

steel_angle_section

RC:

rc_rect_section (b,h)

rebar_main (상/하부 포함 가능)

stirrup (D10@150 등)

기타:

story_tag (3F, B2 등)

member_token (B12, G5 등) — 선택: token은 테이블 파싱에서 보통 충분

5.2 spec_json 표준 예시
H형강
{
  "H_mm": 400,
  "B_mm": 200,
  "tw_mm": 8,
  "tf_mm": 13,
  "family": "steel_h"
}

BOX(RHS/SHS)
{
  "H_mm": 200,
  "B_mm": 200,
  "t_mm": 9,
  "family": "steel_box"
}

PIPE
{
  "D_mm": 165.2,
  "t_mm": 6,
  "family": "steel_pipe"
}

Rebar(상/하부 주근 예시)
{
  "As_top": [{"bar":"D22","n":4}],
  "As_bot": [{"bar":"D22","n":4}],
  "notes": "TOP/BOT"
}

Stirrup
{
  "bar":"D10",
  "s_mm":150,
  "legs":2
}

Story tag
{
  "story_norm":"3F",
  "raw":"3층"
}

6) evidence_json 규격(Resolve/감사/하이라이트 핵심)

이건 “나중에 사람들이 믿고 승인할 수 있는 시스템”을 만드는 핵심이라서 표준 스키마로 고정하는 게 좋아.

6.1 member_spec_links.evidence_json 표준
{
  "source": "table_schema | table | leader | manual",
  "cad_artifact_id": 1,

  "table": {
    "table_id": 10,
    "row_idx": 12,
    "col_idx": 3,
    "cell_entity_ids": ["1A2B", "1A2C"],
    "cell_bbox": {"xmin":0,"ymin":0,"xmax":0,"ymax":0}
  },

  "leader": {
    "leader_entity_id": "00FF",
    "text_entity_id": "0100",
    "text_bbox": {"xmin":0,"ymin":0,"xmax":0,"ymax":0}
  },

  "match": {
    "distance": 235.4,
    "distance_units": "mm",
    "score": 0.92,
    "rule": "nearest_cell_to_member_tag"
  },

  "snippets": [
    {"kind":"token","text":"B12"},
    {"kind":"story","text":"3F"},
    {"kind":"section","text":"H-400x200x8x13"}
  ],

  "provenance": {
    "extractor": "dxf_table_v2",
    "extractor_version": "0.3.0",
    "timestamp": "2025-12-21T10:12:00Z",
    "params": {"line_tol":1.5, "cluster_eps":8.0}
  }
}

최소 요구(진짜 최소)

source

cad_artifact_id

table.table_id,row_idx,col_idx 또는 leader.text_entity_id 중 하나

match.distance + match.score (안 넣어도 되지만 품질/디버깅에 매우 도움)

6.2 token_story_maps.evidence_json(다층 동일 라벨 해결)
{
  "source":"table_row_parse",
  "table_id":10,
  "row_idx":12,
  "token_raw":"B12(3F)",
  "token_norm":"B12",
  "story_norm":"3F",
  "confidence":0.91
}

7) DXF 파서 구현 체크리스트(실제 개발 순서)

여기부터가 “지금 당장 개발 티켓으로 쪼개기 좋은” 체크리스트야.

7.1 입력/메타

 DXF 읽기(파이썬: ezdxf 계열 추천, 필요 시 대체 라이브러리)

 $INSUNITS 읽어서 units 결정 → artifact.meta_json에 저장

 레이어 목록/도면 extents 저장(디버그용)

7.2 텍스트 추출(TEXT/MTEXT)

 TEXT/MTEXT 엔티티 수집

 MTEXT 포맷 제거/정규화 함수 작성

 엔티티 bbox 계산(가능하면), 아니면 insertion point + height로 근사

 cad_entities(또는 meta_json)에 handle/layer/type/raw_text 저장

7.3 테이블 검출(최소 2전략)

전략 1: Grid line 기반(정확도가 높음)

 LINE/LWPOLYLINE에서 수평/수직 선분 후보 추출

 선분 클러스터링(좌표 tolerance) → 그리드 생성

 교차점으로 cell bbox 생성

 텍스트를 cell에 할당(point-in-rect 또는 bbox overlap)

 cad_tables/cad_table_cells 저장

전략 2: Text cluster 기반(그리드 못 찾을 때 fallback)

 특정 영역에서 텍스트가 “행렬 패턴”으로 모여있는지 탐지

 y 기준으로 row cluster, x 기준으로 col cluster

 셀 bbox는 클러스터 centroid 기반으로 생성(근사)

 confidence 낮게(0.4~0.6) 저장

7.4 스펙(cad_specs) 추출

 텍스트/리더 텍스트에서 regex로 단면/철근/층 태그 추출

 spec_kind + spec_json 생성

 cad_specs 저장(method = "leader"|"text")

7.5 리더(Leader) 콜아웃 연결(선택이지만 강력)

 LEADER/MLEADER 엔티티의 끝점 주변 텍스트를 붙여 “callout” 생성

 callout 텍스트를 cad_specs로 저장 + leader_entity_id 기록

 나중에 member 중심점과 callout 위치 거리로 매칭할 때 evidence가 매우 좋아짐

7.6 품질/디버깅(강추)

 “추출 결과를 SVG로 덤프” 기능(테이블 bbox, 셀 bbox, 텍스트 점)

 Regression fixture로 특정 DXF에서 cell count/sample text가 안정적인지 테스트

8) Resolve 패널 구현을 위한 API 목록(서버 도구 “계약”)

Resolve UI가 안정적으로 돌아가려면 아래 API는 “계약”으로 고정하는 게 좋아.

8.1 데이터 조회(패널 로딩/리프레시)

structai_quality_summary(model_id, analysis_run_id?)

structai_specs_list_links(cad_artifact_id, model_id, status="suggested")

structai_token_story_conflicts(cad_artifact_id, model_id)

structai_design_list_patch_runs(model_id)

(선택) structai_dataset_get_active_all()

(선택) structai_approval_read(entity_type, entity_id, project_id) / dashboard

8.2 상태 변경(Confirm/Reject/Undo)

structai_specs_set_link_status(link_id, to_status, reason?)

(권장 추가) structai_token_story_set_status(map_id, to_status)
→ conflict에서 사람이 하나를 confirmed로 확정하는 버튼 필요

structai_design_apply_specs_to_inputs(cad_artifact_id, model_id, overwrite_keys=false) → patch_run_id 반환

structai_design_rollback_patch(patch_run_id, mode="keys_only"|"hard")

8.3 자동 확정(대량 처리)

structai_specs_auto_confirm_table_schema(cad_artifact_id, model_id)

structai_token_story_auto_confirm(cad_artifact_id, model_id)

9) Resolve 패널 UI/이벤트 흐름(구현 체크리스트)
9.1 UI 레이아웃(추천)

좌측 리스트 + 우측 상세 패널(2-column)

왼쪽:

Tabs:

Suggested Specs

Conflicts (token-story)

Missing(quality summary)

Patches(롤백)

오른쪽:

선택된 항목 상세

부재 정보(member_uid, story, section/type)

spec 원문(raw_text), 파싱 결과(spec_json)

evidence(테이블 위치/리더 위치/거리/스코어)

버튼: Confirm / Reject / Open evidence / Jump to CAD

9.2 Webview ↔ Extension ↔ MCP 메시지 프로토콜(권장)
(1) 초기 로딩/리프레시

webview → extension:

{ "type":"refresh", "cad_artifact_id":1, "model_id":1, "analysis_run_id":1 }


extension → server 호출:

quality_summary

specs_list_links(suggested)

token_story_conflicts

patch_runs

extension → webview:

{
  "type":"data",
  "quality": {...},
  "suggestedLinks": [...],
  "conflicts": {...},
  "patches": [...]
}

(2) Suggested link 선택

webview:

{ "type":"selectLink", "link_id": 55 }


(선택적으로 서버 조회를 하지 않고, 이미 내려받은 리스트에서 상세 표시 가능)

(3) Confirm/Reject

webview:

{ "type":"setLinkStatus", "link_id":55, "to_status":"confirmed", "reason":"table match ok" }


extension:

structai_specs_set_link_status

성공 시 refresh 자동 호출(또는 로컬 상태만 업데이트 후 부분 refresh)

(4) Apply Specs(패치 생성)

webview:

{ "type":"applySpecs", "cad_artifact_id":1, "model_id":1 }


extension:

structai_design_apply_specs_to_inputs → patch_run_id 반환

이후 refresh

(5) Rollback Patch

webview:

{ "type":"rollbackPatch", "patch_run_id": 12, "mode":"keys_only" }

(6) Auto confirm

webview:

{ "type":"autoConfirmTableSchema", "cad_artifact_id":1, "model_id":1 }

9.3 “하이라이트/근거 점프” 기능(강추)

evidence에 table_id,row_idx,col_idx 또는 cad_entity_id/handle이 있으므로:

(가능) CAD 뷰어가 있으면 해당 bbox로 줌/하이라이트

(최소) “evidence raw JSON 보기” 버튼으로 디버깅

10) Resolve에서 자주 터지는 케이스 & 방어 로직(현장 필수)
10.1 다층 동일 라벨(B12가 2F/3F에 동시에)

token만으로 매핑하면 충돌이 100% 발생

해결:

table row parse에서 story_norm을 최대한 뽑는다

token_story_maps로 (token,story) 단위로 확정

Resolve 패널에서 conflict 탭으로 강제 확인

10.2 표 헤더가 없거나 2줄 이상

그래서 v2가 필수(다중 헤더 결합 + content 기반 fallback)

10.3 철골 비대칭 단면(channel/angle)

computed props는 fallback에 두고

catalog 값이 있으면 덮어쓰기(priority)

catalog가 없으면 “warnings”를 design_json에 남겨 Resolve/QA에서 보이게

10.4 “NA를 숨기지 않기”

정보 없는데 임의 추정하면 신뢰가 무너짐

quality_summary에서 NA 이유(부족 키)를 보여주고,

Resolve에서 그 키를 채우는 행동(스펙 확정/섹션 resolve/내력 계산)을 바로 연결

11) 개발 티켓으로 바로 쪼갠 “실행 플랜”(2주 단위 추천)
Sprint 1 (DXF 최소 파서 + 테이블만)

 TEXT/MTEXT 추출 + 정규화

 grid 기반 테이블 검출 1차 구현

 cad_tables/cad_table_cells 저장

 table_schema_v2 + parse_rows_v2 연결

 Resolve에서 “Suggested rows 미리보기” 확인 가능

Sprint 2 (spec + evidence + resolve 확정 UX)

 specs regex 적용(cad_specs 생성)

 table row에서 section/rebar 추출 → member_spec_links suggested 생성

 Resolve 패널 Confirm/Reject + 자동 확정 + Apply Specs + Rollback 완성

Sprint 3 (상용 비교 + 회귀 + CI + QA 패널)

 benchmark import/compare/report

 regression suite/run/report + isolated DB

 GitHub Actions regression gate

 QA 패널에서 run detail 표시

Sprint 4 (거버넌스/승인/데이터셋)

 dataset register/activate/notify + project events

 approval workflow 3단계 + roles/permissions

 Governance 패널로 승인 투표/리포트 서명

원하면 다음으로는(바로 이어서)
DXF “표”를 안정적으로 잡기 위한 실제 알고리즘(선분 클러스터링/교차점/셀 생성)과, MTEXT 포맷 제거/문자 깨짐 처리 규칙까지 “구현용 의사코드 + 테스트 케이스” 형태로 더 내려줄게.

좋습니다. 아래는 요청하신 대로 **DXF “표”를 안정적으로 잡기 위한 실제 알고리즘(선분 클러스터링 → 교차점 → 셀 생성 → 텍스트 배치)**과 MTEXT 포맷 제거/문자 깨짐 처리 규칙, 그리고 **구현용 의사코드 + 테스트 케이스(회귀에 넣을 수 있는 형태)**까지 한 번에 정리한 문서입니다.

1) DXF “표(table)” 추출 알고리즘: 실전형 설계
1.1 표 추출의 기본 전략(2단계)

DXF에서 표는 크게 두 부류입니다.

그리드 선(수평/수직 라인)로 실제 표를 그려둔 경우
→ “라인 기반 Grid”가 가장 정확하고 안정적 (우선)

그리드 선이 없고 텍스트가 행렬처럼 배치된 경우 (혹은 선이 깨져 있음)
→ “텍스트 클러스터 기반” fallback

결론: 라인 기반 → 실패하면 텍스트 클러스터로 내려가는 구조가 베스트입니다.

2) 라인 기반 Grid 표 검출: 핵심 알고리즘
2.1 입력 데이터(필요)

DXF에서 가져올 엔티티:

LINE

LWPOLYLINE (또는 POLYLINE)의 세그먼트

(선택) INSERT 블록 내부 라인도 펼쳐서(권장)

텍스트 엔티티:

TEXT, MTEXT (표 내용용)

2.2 파라미터(권장 기본값)

이 값들은 회귀 테스트로 안정화시키면 돼요.

angle_tol_deg = 2.0
수평/수직 판정 허용 각도(도면 약간 기울어짐 대응)

coord_tol = 1.5 (units가 mm 기준일 때)
수직선의 x좌표 클러스터링, 수평선의 y좌표 클러스터링 tolerance

merge_gap_tol = 3.0
같은 x(또는 y) 라인에서 세그먼트가 끊겨있을 때 이어 붙이는 gap tolerance

min_cells = 16
테이블로 인정할 최소 셀 개수(예: 4x4)

component_gap = 20.0
서로 가까운 라인들은 같은 표 컴포넌트로 묶기 위한 거리 tolerance

units가 “m”라면 위 값들을 적절히 스케일해야 합니다.
그래서 INSUNITS 기반으로 mm로 normalize하거나, tolerance도 단위에 맞춰 scaling하세요.

2.3 처리 파이프라인(요약)

선분 추출 → 수평/수직 분류

수평선은 y로 클러스터링, 수직선은 x로 클러스터링

클러스터 내에서 세그먼트 merge(끊어진 선 이어붙이기)

라인들끼리 Connected Component(근접 그래프)로 “표 후보” 분리

각 컴포넌트에서 x좌표 집합, y좌표 집합을 만들고 Grid 생성

인접 x[i]~x[i+1], y[j]~y[j+1]로 cell bbox 생성

텍스트를 cell에 배치 → cad_table_cells 생성

결과를 DB에 저장(테이블 bbox + 셀 텍스트 + 근거)

3) 구현용 의사코드(라인 기반) — 바로 코드로 옮길 수 있게

아래는 라이브러리 독립적인 형태로 적었고, 실제 DXF 읽기 부분만 ezdxf로 채우면 됩니다.

3.1 데이터 구조(간단 모델)
from dataclasses import dataclass
from typing import List, Optional, Tuple, Dict
import math

@dataclass
class Segment:
    x1: float; y1: float
    x2: float; y2: float
    handle: Optional[str] = None
    layer: Optional[str] = None

    def bbox(self):
        return (min(self.x1, self.x2), min(self.y1, self.y2),
                max(self.x1, self.x2), max(self.y1, self.y2))

    def length(self):
        return math.hypot(self.x2-self.x1, self.y2-self.y1)

    def angle_deg(self):
        return math.degrees(math.atan2(self.y2-self.y1, self.x2-self.x1))

@dataclass
class TextEnt:
    text: str
    x: float; y: float
    bbox: Optional[Tuple[float,float,float,float]] = None
    handle: Optional[str] = None
    layer: Optional[str] = None
    height: Optional[float] = None
    rotation_deg: float = 0.0

3.2 수평/수직 판정
def is_horizontal(seg: Segment, angle_tol_deg: float) -> bool:
    a = seg.angle_deg() % 180.0
    return (abs(a - 0.0) <= angle_tol_deg) or (abs(a - 180.0) <= angle_tol_deg)

def is_vertical(seg: Segment, angle_tol_deg: float) -> bool:
    a = seg.angle_deg() % 180.0
    return abs(a - 90.0) <= angle_tol_deg

3.3 좌표 클러스터링(수직은 x, 수평은 y)

클러스터링은 “정렬 후 인접 값이 tol 이내면 같은 그룹” 방식이 가장 안정적입니다.

def cluster_by_coord(values: List[float], tol: float) -> List[List[float]]:
    if not values:
        return []
    values = sorted(values)
    clusters = [[values[0]]]
    for v in values[1:]:
        if abs(v - clusters[-1][-1]) <= tol:
            clusters[-1].append(v)
        else:
            clusters.append([v])
    return clusters

def cluster_segments_vertical(segments: List[Segment], coord_tol: float) -> Dict[float, List[Segment]]:
    # 대표 x를 key로: 같은 x 라인 묶기
    xs = [(seg.x1 + seg.x2)/2.0 for seg in segments]  # 수직이면 x가 거의 동일
    clusters = cluster_by_coord(xs, coord_tol)
    out = {}
    for cl in clusters:
        rep = sum(cl)/len(cl)
        out[rep] = []
    # rep에 할당
    for seg in segments:
        x = (seg.x1 + seg.x2)/2.0
        rep = min(out.keys(), key=lambda r: abs(r-x))
        out[rep].append(seg)
    return out

def cluster_segments_horizontal(segments: List[Segment], coord_tol: float) -> Dict[float, List[Segment]]:
    ys = [(seg.y1 + seg.y2)/2.0 for seg in segments]  # 수평이면 y가 거의 동일
    clusters = cluster_by_coord(ys, coord_tol)
    out = {}
    for cl in clusters:
        rep = sum(cl)/len(cl)
        out[rep] = []
    for seg in segments:
        y = (seg.y1 + seg.y2)/2.0
        rep = min(out.keys(), key=lambda r: abs(r-y))
        out[rep].append(seg)
    return out

3.4 끊긴 선 merge(같은 x 또는 y 라인 안에서)

수직 라인은 y 구간을, 수평 라인은 x 구간을 이어붙입니다.

def merge_1d_intervals(intervals: List[Tuple[float,float]], gap_tol: float) -> List[Tuple[float,float]]:
    if not intervals:
        return []
    intervals = sorted((min(a,b), max(a,b)) for a,b in intervals)
    merged = [intervals[0]]
    for a,b in intervals[1:]:
        la, lb = merged[-1]
        if a <= lb + gap_tol:
            merged[-1] = (la, max(lb, b))
        else:
            merged.append((a,b))
    return merged

def merge_vertical_line(x_rep: float, segs: List[Segment], gap_tol: float) -> List[Segment]:
    intervals = [(s.y1, s.y2) for s in segs]
    merged = merge_1d_intervals(intervals, gap_tol)
    return [Segment(x_rep, a, x_rep, b) for a,b in merged]

def merge_horizontal_line(y_rep: float, segs: List[Segment], gap_tol: float) -> List[Segment]:
    intervals = [(s.x1, s.x2) for s in segs]
    merged = merge_1d_intervals(intervals, gap_tol)
    return [Segment(a, y_rep, b, y_rep) for a,b in merged]

3.5 “표 후보” 분리: Connected Components(근접 그래프)

라인이 많으면 전체 그리드가 여러 개 테이블로 섞입니다.
가장 단순하고 강한 방법은 “bbox가 겹치거나 가까우면 연결”로 그래프 컴포넌트를 나누는 겁니다.

def bbox_expand(bb, d):
    x1,y1,x2,y2 = bb
    return (x1-d, y1-d, x2+d, y2+d)

def bbox_intersects(a, b) -> bool:
    ax1,ay1,ax2,ay2 = a
    bx1,by1,bx2,by2 = b
    return not (ax2 < bx1 or bx2 < ax1 or ay2 < by1 or by2 < ay1)

def connected_components(lines: List[Segment], component_gap: float) -> List[List[Segment]]:
    # 간단 BFS
    bbs = [bbox_expand(l.bbox(), component_gap) for l in lines]
    n = len(lines)
    seen = [False]*n
    comps = []
    for i in range(n):
        if seen[i]: 
            continue
        q = [i]
        seen[i] = True
        comp = []
        while q:
            u = q.pop()
            comp.append(lines[u])
            for v in range(n):
                if seen[v]:
                    continue
                if bbox_intersects(bbs[u], bbs[v]):
                    seen[v] = True
                    q.append(v)
        comps.append(comp)
    return comps


성능 개선은 나중에 spatial index(R-tree)로 바꾸면 됩니다.
초기는 위 방식으로도 충분히 동작합니다(테이블 수가 많아지면 최적화).

3.6 컴포넌트에서 Grid 생성(셀 bbox 생성)

컴포넌트에 포함된 수직선의 x, 수평선의 y를 모아서 인접 구간으로 셀 생성합니다.

def extract_grid_from_component(component: List[Segment], angle_tol_deg=2.0,
                                coord_tol=1.5, merge_gap_tol=3.0):
    vertical = [s for s in component if is_vertical(s, angle_tol_deg) and s.length() > 5]
    horizontal = [s for s in component if is_horizontal(s, angle_tol_deg) and s.length() > 5]

    vclusters = cluster_segments_vertical(vertical, coord_tol)
    hclusters = cluster_segments_horizontal(horizontal, coord_tol)

    merged_v = []
    for xrep, segs in vclusters.items():
        merged_v.extend(merge_vertical_line(xrep, segs, merge_gap_tol))

    merged_h = []
    for yrep, segs in hclusters.items():
        merged_h.extend(merge_horizontal_line(yrep, segs, merge_gap_tol))

    xs = sorted({round((s.x1+s.x2)/2.0, 6) for s in merged_v})
    ys = sorted({round((s.y1+s.y2)/2.0, 6) for s in merged_h})

    return xs, ys, merged_v, merged_h


셀 bbox:

def build_cells(xs: List[float], ys: List[float]):
    # y는 보통 위가 큼, 아래가 작음. row_idx=0은 "표의 맨 위"
    # 따라서 ys를 내림차순으로 쓰는 편이 UI/헤더 처리에 유리
    ys_desc = sorted(ys, reverse=True)
    cells = []
    for r in range(len(ys_desc)-1):
        y_top = ys_desc[r]
        y_bot = ys_desc[r+1]
        for c in range(len(xs)-1):
            x_left = xs[c]
            x_right = xs[c+1]
            cells.append((r, c, (x_left, y_bot, x_right, y_top)))  # bbox: xmin,ymin,xmax,ymax
    return cells

3.7 텍스트를 셀에 배치(가장 중요한 단계)

가장 안정적인 방식은 **“텍스트 앵커 포인트가 포함되는 셀 찾기”**입니다.

def point_in_bbox(x, y, bb) -> bool:
    x1,y1,x2,y2 = bb
    return (x1 <= x <= x2) and (y1 <= y <= y2)

def assign_texts_to_cells(texts: List[TextEnt], cells: List[Tuple[int,int,Tuple[float,float,float,float]]]):
    cell_map = {}  # (r,c) -> list of texts
    for t in texts:
        placed = False
        for r,c,bb in cells:
            if point_in_bbox(t.x, t.y, bb):
                cell_map.setdefault((r,c), []).append(t)
                placed = True
                break
        if not placed:
            # (옵션) bbox 기반 overlap 할당 or nearest bbox 할당(텍스트가 셀 경계 밖에 있는 경우)
            pass
    return cell_map

def finalize_cell_text(cell_map):
    # 같은 셀에 여러 텍스트가 있으면 y 내림차순 정렬 후 join
    out = {}
    for (r,c), items in cell_map.items():
        items_sorted = sorted(items, key=lambda t: (-t.y, t.x))
        out[(r,c)] = "\n".join(t.text for t in items_sorted if t.text.strip())
    return out

(권장) 셀 정렬/타이포 처리 팁

같은 셀에 텍스트가 여러개 들어오는 경우가 많습니다(줄바꿈/주석).

join 규칙을 고정해 두어야 회귀가 안정됩니다:

\n로 join

공백 정규화된 상태에서 join

4) 라인 기반이 실패할 때: 텍스트 클러스터 기반 표 추정(Fallback)

라인이 거의 없거나, 블록 테이블로 들어가서 선을 읽기 어렵다면 fallback을 사용합니다.

4.1 텍스트만으로 행/열 클러스터 만들기

핵심은 “Y 기준 row 클러스터 → X 기준 col 클러스터”입니다.

def cluster_1d_points(vals: List[float], tol: float) -> List[float]:
    # 클러스터 대표값 리스트 반환
    clusters = cluster_by_coord(vals, tol)
    return [sum(c)/len(c) for c in clusters]

def infer_text_grid(texts: List[TextEnt], row_tol: float, col_tol: float):
    ys = [t.y for t in texts]
    xs = [t.x for t in texts]

    row_centers = sorted(cluster_1d_points(ys, row_tol), reverse=True)
    col_centers = sorted(cluster_1d_points(xs, col_tol))

    # 각 텍스트를 가장 가까운 row/col 센터로 할당
    grid = {}
    for t in texts:
        r = min(range(len(row_centers)), key=lambda i: abs(row_centers[i]-t.y))
        c = min(range(len(col_centers)), key=lambda i: abs(col_centers[i]-t.x))
        grid.setdefault((r,c), []).append(t)

    # cell bbox는 근사로 만들거나(센터 사이 midpoints) 그냥 point 기반 셀로 저장(최소)
    return row_centers, col_centers, grid

4.2 row_tol/col_tol 자동 설정(현장형)

row_tol = median_text_height * 1.2~1.8

col_tol = median_char_width * 2.0~4.0
(char_width는 text_height * 0.6 정도로 추정 가능)

fallback은 “정확한 bbox”보다 “행/열 정렬”이 목적이라, confidence를 낮게 저장하는 게 좋습니다.

5) MTEXT 포맷 제거(실전 규칙 + 구현 스니펫)

DXF MTEXT는 {...} 그룹과 \ 제어코드가 섞여서 들어옵니다.
목표는 **“사람이 보는 텍스트”**로 최대한 복원하는 겁니다.

5.1 처리 규칙(추천)

\P → 줄바꿈

\~ → 공백

%%c, %%d, %%p → Ø, °, ±

{...} 그룹은:

그룹 안에서 ; 이후가 실제 텍스트인 경우가 많음

가장 보수적으로는 “{” “}” 제거하고 안의 텍스트만 남김

\H, \W, \A, \C, \f 등 포맷 코드 제거

다중 공백 정리

곱셈 문자 통일: ×→x

5.2 구현용 의사코드(실제 파이썬으로 바로 가능)
import re

_RX_PARA = re.compile(r"\\P")
_RX_NBSP = re.compile(r"\\~")
_RX_FORMAT = re.compile(r"\\[A-Za-z][^; ]*;?")  # 대략적인 포맷 제거(보수적으로)
_RX_BRACES = re.compile(r"[{}]")

def normalize_mtext(raw: str) -> str:
    if raw is None:
        return ""

    s = raw

    # 1) paragraph / nbsp
    s = _RX_PARA.sub("\n", s)
    s = _RX_NBSP.sub(" ", s)

    # 2) special codes
    s = s.replace("%%c", "Ø").replace("%%C", "Ø")
    s = s.replace("%%d", "°").replace("%%D", "°")
    s = s.replace("%%p", "±").replace("%%P", "±")

    # 3) braces 제거(가장 단순/안전)
    s = _RX_BRACES.sub("", s)

    # 4) \H...\; 같은 포맷 시퀀스 제거(너무 과하면 텍스트도 날아가니 회귀로 튜닝)
    s = _RX_FORMAT.sub("", s)

    # 5) 곱셈/대시 통일
    s = s.replace("×", "x").replace("－", "-")

    # 6) 공백 정리
    s = re.sub(r"[ \t]+", " ", s)
    s = re.sub(r"\n[ \t]+", "\n", s)
    s = s.strip()

    return s


포맷 제거 정규식은 도면마다 편차가 큽니다.
반드시 회귀 fixture에 실제 MTEXT 샘플 문자열을 넣고, normalize 결과를 golden으로 고정해서 튜닝하세요.

6) 문자 깨짐(인코딩) 처리 규칙(현장형)
6.1 DXF 헤더에서 codepage 읽기

옛 DXF는 한국어가 ANSI_949로 들어오는 경우가 많습니다.

$DWGCODEPAGE 값 예: ANSI_949, ANSI_1252 등

codepage → python codec 매핑(권장)

ANSI_949 → cp949

ANSI_1252 → cp1252

ANSI_932 → cp932(일본어)

UTF-8 계열이면 utf-8

6.2 ezdxf로 읽을 때 권장 흐름

1차: 기본 읽기

2차: $DWGCODEPAGE 기반으로 재시도(가능하면)

3차: “깨짐 점수”로 후보 encoding 여러 개 재시도(최후)

깨짐 점수(간단 휴리스틱)

텍스트에 �(U+FFFD) 비율이 높으면 깨짐으로 판단

또는 한글이 있어야 하는 도면인데 한글 범위(가-힣)가 거의 없으면 재시도

이 부분은 라이브러리/파일 타입에 따라 달라서 “원칙 + 회귀 데이터”로 안전하게 가는 게 좋습니다.

7) 디버깅/검증을 위한 SVG 덤프(강추)

DXF 표 추출은 눈으로 검증이 가장 빠릅니다.
그래서 “추출 결과를 SVG로 저장” 기능을 꼭 넣으세요.

7.1 SVG 덤프 의사코드
def dump_svg(lines: List[Segment], cells, texts: List[TextEnt], out_path: str):
    # 매우 단순한 SVG: 선/셀 bbox/텍스트 점
    # 실제로는 bbox 스케일링/좌표 뒤집기(y축) 처리 필요
    xmins = []; ymins=[]; xmaxs=[]; ymaxs=[]
    for s in lines:
        x1,y1,x2,y2 = s.bbox()
        xmins.append(x1); ymins.append(y1); xmaxs.append(x2); ymaxs.append(y2)
    for _,_,bb in cells:
        x1,y1,x2,y2 = bb
        xmins.append(x1); ymins.append(y1); xmaxs.append(x2); ymaxs.append(y2)
    for t in texts:
        xmins.append(t.x); ymins.append(t.y); xmaxs.append(t.x); ymaxs.append(t.y)

    xmin=min(xmins); ymin=min(ymins); xmax=max(xmaxs); ymax=max(ymaxs)
    w = xmax-xmin; h = ymax-ymin

    def sx(x): return x - xmin
    def sy(y): return (ymax - y)  # y축 뒤집기

    svg = []
    svg.append(f'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 {w} {h}">')

    # lines
    for s in lines:
        svg.append(f'<line x1="{sx(s.x1)}" y1="{sy(s.y1)}" x2="{sx(s.x2)}" y2="{sy(s.y2)}" stroke="black" stroke-width="0.5"/>')

    # cells
    for r,c,bb in cells:
        x1,y1,x2,y2 = bb
        svg.append(f'<rect x="{sx(x1)}" y="{sy(y2)}" width="{x2-x1}" height="{y2-y1}" fill="none" stroke="red" stroke-width="0.3"/>')

    # texts
    for t in texts:
        svg.append(f'<circle cx="{sx(t.x)}" cy="{sy(t.y)}" r="1.2" fill="blue"/>')

    svg.append("</svg>")
    open(out_path, "w", encoding="utf-8").write("\n".join(svg))

8) 테스트 케이스(회귀에 바로 넣을 수 있는 형태)

아래 테스트들은 DXF 라이브러리 없이도 순수 파이썬으로 돌릴 수 있게 설계했습니다.
즉, “추출 알고리즘의 핵심(클러스터링/셀 생성/텍스트 배치/정규화)”을 회귀로 고정하는데 바로 쓸 수 있습니다.

8.1 MTEXT 정규화 테스트
def test_normalize_mtext_basic():
    raw = r"{\fArial|b0|i0;H-400×200×8×13}\P(3층)\P%%c165.2x6"
    out = normalize_mtext(raw)
    assert "H-400x200x8x13" in out
    assert "\n" in out
    assert "Ø165.2x6" in out

8.2 선 클러스터/merge 테스트
def test_merge_vertical_line():
    segs = [
        Segment(10.0, 0.0, 10.2, 50.0),   # 거의 수직
        Segment(10.1, 52.0, 10.0, 100.0)  # gap 2
    ]
    vcl = cluster_segments_vertical(segs, coord_tol=0.5)
    # 대표 x 키가 하나여야 함
    assert len(vcl) == 1
    xrep = list(vcl.keys())[0]
    merged = merge_vertical_line(xrep, vcl[xrep], gap_tol=3.0)
    # 하나로 이어져야 함
    assert len(merged) == 1
    assert merged[0].y1 <= 0.0 and merged[0].y2 >= 100.0

8.3 3x3 그리드 셀 생성 + 텍스트 배치 테스트
def test_build_cells_and_assign():
    # 4 vertical lines (x=0,10,20,30), 4 horizontal lines (y=0,10,20,30)
    lines = []
    for x in [0,10,20,30]:
        lines.append(Segment(x, 0, x, 30))
    for y in [0,10,20,30]:
        lines.append(Segment(0, y, 30, y))

    xs, ys, mv, mh = extract_grid_from_component(lines, angle_tol_deg=1.0, coord_tol=0.1, merge_gap_tol=0.1)
    cells = build_cells(xs, ys)
    assert len(cells) == 9  # 3x3

    texts = [
        TextEnt("A", x=5,  y=25),  # row0 col0
        TextEnt("B", x=15, y=25),  # row0 col1
        TextEnt("C", x=25, y=25),  # row0 col2
    ]
    cmap = assign_texts_to_cells(texts, cells)
    final = finalize_cell_text(cmap)
    assert final[(0,0)] == "A"
    assert final[(0,1)] == "B"
    assert final[(0,2)] == "C"

8.4 텍스트 클러스터 fallback 테스트
def test_infer_text_grid():
    # 2 rows, 3 cols
    texts = [
        TextEnt("H1", x=10, y=100, height=2),
        TextEnt("H2", x=30, y=100, height=2),
        TextEnt("H3", x=50, y=100, height=2),
        TextEnt("R1", x=10, y=90,  height=2),
        TextEnt("R2", x=30, y=90,  height=2),
        TextEnt("R3", x=50, y=90,  height=2),
    ]
    row_centers, col_centers, grid = infer_text_grid(texts, row_tol=3.0, col_tol=8.0)
    assert len(row_centers) == 2
    assert len(col_centers) == 3
    assert any(t.text == "H1" for t in grid[(0,0)])
    assert any(t.text == "R3" for t in grid[(1,2)])

9) “실제 DXF 연동” 시 구현 팁(현장 노하우)
9.1 레이어 필터링 옵션(초기엔 꼭 넣기)

도면에 선이 너무 많으면 table 검출이 난이도가 급상승합니다.
초기에는 아래 옵션을 넣어주세요.

include layers: TABLE, TB, GRID 같은 레이어만 우선

exclude layers: HATCH, DIM, CENTER 등 제외

이거 하나만 넣어도 테이블 검출 정확도가 2배 이상 올라가는 경우가 많습니다.

9.2 “표 후보 bbox”를 먼저 찾고 그 안에서만 세밀 처리

도면 전체에서 그리드를 만들지 말고,

“선이 밀집한 영역”을 먼저 후보로 잡아(connected components가 이 역할)

후보 bbox 안에서만 텍스트를 할당하세요.

9.3 회전 테이블(고급)

표가 기울어져 있으면:

주요 라인 방향의 지배각(theta)을 추정(PCA 또는 라인 각도 히스토그램 peak)

좌표계를 -theta 만큼 회전해서 “축정렬 표”로 만든 뒤 같은 로직 적용

결과 bbox는 원 좌표로 역변환

초기 MVP에서는 angle_tol_deg를 2~3도로 키우고 “약간 기울어진 표”까지 커버하는 게 현실적입니다.

10) “바로 다음 구현”을 위한 추천 모듈 구성

mcp_server/parsing/dxf_text.py

extract_text_entities(doc)

normalize_mtext(raw)

mcp_server/parsing/dxf_lines.py

extract_segments(doc)

cluster_segments_*, merge_*

mcp_server/parsing/dxf_tables.py

detect_tables_by_lines(segments, params)

assign_texts_to_cells(texts, cells)

fallback_tables_by_text_clusters(texts, params)

dump_svg(...) (디버그 전용)

mcp_server/tools/structai_import_dxf.py (또는 server.py tool 내부)

artifact 등록 + 위 파서 호출 + DB 저장

원하면, 다음으로는 **“ezdxf를 사용해 실제 DXF에서 LINE/LWPOLYLINE/TEXT/MTEXT/MLEADER를 어떻게 안전하게 추출할지”**를

실전 코드 스니펫(예: layout 순회, block explode, DWGCODEPAGE 처리)

흔한 실패 케이스(블록 속성(ATTRIB), MTEXT 내부 제어코드 극단 케이스)
까지 포함해서 이어서 정리해줄게요.
source .venv/bin/activate
