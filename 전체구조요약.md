아래 문서는 우리가 Step9 ~ Step13까지(그리고 그 이전 단계에서 이미 전제했던 구조: MCP 서버 + SQLite + Artifact/Parsing/Design/Check 파이프라인 + VS Code 확장)를 한 장의 체계로 통합해서 정리한 요약 계획서야.
(코드는 “그대로 복사해서 파일에 붙이는 단위”가 아니라, 지금까지 제시한 코드/스니펫을 모듈/기능 기준으로 재정렬한 “설계 + 구현 가이드” 형태로 정리했어.)

0. 제품 비전

VS Code(커서AI 유사 UX) + 구조 엔지니어링 워크플로우 통합

오른쪽 AI 대화창에서 작업을 수행하되, 단순 질의응답이 아니라:

CAD(DXF), PDF, MD, 구조해석(FEA) 결과, 모델링 데이터

단면/철근/층/부재 매핑, 구조기준(KDS 등) 조항/룰 적용

부재별 안전성 평가 결과 보고서 생성 및 승인/감사 로그

위 모든 것을 **한 “프로젝트 메모리(단일 DB)”**에서 관리한다.

1. 핵심 사용자 시나리오(End-to-End)
시나리오 A: 도면 기반 자동 사양/부재 매핑 → 안전성 평가

DXF 업로드 → 표(부재표/철근표) 자동 인식

도면의 리더/표/텍스트에서 부재 토큰(B12 등) + 층(3F 등) + 단면/H형강/철근 사양 추출

해석 모델의 부재(member_uid, story, section 등)과 자동 매핑(token↔member)

추출된 사양(spec)을 설계 입력(design_inputs)에 적용(패치 생성)

내력 계산(capacity) + 해석결과(demand) 기반 체크 실행

결과 보고서 생성 + 승인 워크플로우(1차/2차/최종) + 서명(무결성) 기록

시나리오 B: 상용프로그램/수기 결과와 자동 비교

ETABS/MIDAS/수기 계산 결과 CSV/JSON 적재(benchmark)

우리 체크 결과(check_run)와 비교(compare_run)

차이 보고서(MD/PDF) 생성 → 승인/감사

시나리오 C: 기능 수정 후 품질 보장(회귀/CI)

Regression suite를 fixture 기반으로 실행

golden 대비 결과 차이가 있으면 자동 FAIL(CI)

의도된 변경이면 golden 업데이트 후 PASS 확인

VS Code QA 탭에서 실패 케이스/차이 확인

2. 전체 아키텍처(요약)
[VS Code Extension]
  - Editor + Right Chat Panel
  - Resolve Panel(매핑/충돌/누락/확정/롤백)
  - QA Panel(회귀/비교/리포트)
  - Projects/Governance Panel(프로젝트/승인/변경공지)

        │ (MCP tool calls)
        ▼

[MCP Server (Python)]
  - Artifact 관리(파일/URI/sha256)
  - Parsing: DXF/표/스펙/층태그 추출
  - Mapping: token-story↔model member 연결
  - Design: 내력 계산(철골/RC 등), section props
  - Check Engine: rulepack + QA profile 적용, 결과 저장
  - Reporting: compare/regression/check 리포트 생성(MD/PDF)
  - Governance: dataset versioning, approvals, signatures, audit logs
  - Regression: fixture 실행, golden 비교, CI

        ▼

[SQLite DB]
  - models, model_members
  - artifacts(원본 파일/리포트) + sha256
  - cad_* (spec/table/story)
  - member_mappings, member_spec_links, token_story_maps
  - member_design_inputs, member_results, check_runs, check_results
  - section_catalog, rulepacks, codebooks, template_sets
  - compare_* (상용비교)
  - regression_* (회귀)
  - qa_profiles, dataset_versions, report_signatures, approvals
  - projects/users/roles/workflow(조직 운영)

3. 데이터 모델(핵심 테이블 그룹)
3.1 “원본/근거” (Artifacts)

artifacts: DXF/PDF/MD/리포트 파일의 URI, sha256, kind, title
→ 모든 결과는 근거 파일과 연결 가능해야 함.

3.2 CAD 인식/추출

cad_specs: 텍스트에서 추출한 단면/철근/층 태그 등의 spec

cad_tables, cad_table_cells: 표 구조/셀 텍스트

cad_table_schemas, cad_table_row_parses: 헤더/컬럼 역할 추론 + 행 단위 파싱

3.3 모델/매핑/사양 적용

models, model_members

member_mappings: CAD token↔model member(confirmed/suggested)

member_spec_links: spec↔member 연결(confirmed/suggested/rejected)

token_story_maps: (token, story) 단위의 매핑(다층 동일 라벨 해결)

3.4 설계/해석/체크

member_design_inputs: 설계 입력(단면/철근/재료/내력 등 JSON)

analysis_runs, member_results: 해석 결과 envelope(JSON)

check_runs, check_results: 체크 결과(ratio/status/citations 등)

3.5 표준화/룰

section_catalog: 형강/단면특성(표준값 우선, priority로 덮어쓰기 제어)

codebooks: 조항/인용 매핑

check_template_sets: 체크 타입별 템플릿 세트

rulepacks: 실제 실행되는 룰팩(템플릿+코드북에서 생성 가능)

3.6 비교/회귀/품질

benchmarks, benchmark_results: 상용/수기 기준값

compare_runs, compare_items, compare_reports: 비교/리포트

regression_suites, regression_cases, regression_runs, regression_case_results, regression_reports: 회귀/리포트

3.7 거버넌스/감사/조직 운영

qa_profiles, model_qa_profiles: 프로젝트 정책(허용오차/예외/범위)

dataset_defs, dataset_versions, dataset_changelogs, dataset_activation_events: 데이터셋 버전 관리 + 활성 변경 이벤트

report_signatures: 리포트 무결성(sha256/HMAC)

approval_workflow_defs, project_workflows, approval_instances, approval_votes: 다단계 승인

projects, project_models, users, roles, project_memberships: 멀티프로젝트/권한

entity_contexts: 결과 재현성용 스냅샷(활성 데이터셋/QA 프로파일/환경)

4. 핵심 파이프라인(도구 호출 흐름)
4.1 도면 → 스펙 추출/매핑 → 설계 입력 적용

structai_import_dxf

structai_cad_parse_specs

structai_cad_detect_story_tags

structai_cad_extract_tables

structai_cad_infer_table_schemas_v2 ✅(Step9: 헤더 다중행/헤더 없음 대응 강화)

structai_token_story_map_build → structai_token_story_auto_confirm ✅(Step9)

structai_specs_from_table_rows → structai_specs_auto_confirm_table_schema

structai_design_apply_specs_to_inputs ✅(Step10: patch_run 기록)

(철골) structai_sections_resolve_members (fallback)

(RC) structai_design_compute_rc_beam_rect

structai_check_run (rulepack + QA profile 적용)

리포트 생성/서명/승인

4.2 상용 비교(compare)

structai_benchmark_import

structai_compare_check_run_to_benchmark

structai_compare_report_generate (MD/PDF)

4.3 회귀(regression) + CI

structai_regression_run_suite_v2 (isolated DB)

structai_regression_report_generate

CLI(regression_cli.py)로 CI에서 PASS/FAIL

VS Code QA 탭에서 run detail 확인

5. “표준 단면 우선” 전략(실무 신뢰 핵심)
원칙

표준 카탈로그(ks_catalog/csv_import) 값이 있으면 그것이 최우선

계산(computed)은 fallback(예외/경고 포함)

section_catalog.priority로 덮어쓰기 정책 고정:

표준값 priority 낮게(예: 10~20)

computed priority 높게(예: 80)

Step9에서 확장한 단면 패밀리

steel_h

steel_box (RHS/SHS/BOX)

steel_pipe (CHS/PIPE)

steel_channel

steel_angle

구현 모듈

mcp_server/parsing/specs.py : 단면/철근/층 파싱 정규식 확장

mcp_server/design/steel_props_more.py : BOX/PIPE/CHANNEL/ANGLE 단면특성 계산(주의/경고 포함)

structai_sections_import_catalog & _upsert_section(priority 비교) : 표준값 우선 저장

structai_sections_resolve_members : 모델 section 문자열 기반 resolve

6. 테이블 인식 고도화(v2)
목적

“부재표/철근표”는 실제로 헤더가 2줄 이상이거나 병합셀/빈셀/헤더 없음이 흔함

v2는 다음을 강화:

헤더 후보 2~3줄 결합

header가 약하면 content 기반 추론(token/story/section column)

token 셀 내부에서 story 동시 추출(B12(3F) 등)

구현 모듈

mcp_server/parsing/table_schema_v2.py

infer_schema_v2()

parse_rows_v2()

도구:

structai_cad_infer_table_schemas_v2

7. “사람이 확정하는” Resolve 워크플로우(안전/감사)
핵심 UI(Resolve Panel)

Suggested Spec Links 목록

Token-Story Conflicts 목록

Missing Inputs(NA 원인) 요약

Apply Specs → patch_run 생성

Rollback patch_run(키 단위 복구 또는 hard)

서버 도구(필수)

structai_specs_list_links

structai_specs_set_link_status (+ decision_logs)

structai_token_story_conflicts

structai_quality_summary

structai_design_apply_specs_to_inputs (patch 기록)

structai_design_list_patch_runs

structai_design_rollback_patch

이 구조 덕분에 “자동화는 제안(suggested)까지만”,
“최종 확정은 사람(confirm)”,
“실수는 롤백으로 되돌림”이 가능해져 실무 안정성이 확 올라간다.

8. 룰/조항 적용의 표준화(Template + Codebook + QA Profile)
8.1 템플릿(check_type별 규격화)

check_template_sets.templates_json에 체크 템플릿을 저장:

ratio_expr, requires, warn/limit, citations_key

8.2 codebook(조항/인용 통합)

조항 문구/근거/링크/버전 등을 codebooks.codebook_json로 관리

8.3 rulepack 생성 자동화

structai_rulepack_generate_from_templates
템플릿 + codebook → 실행 rulepack 생성/활성화

8.4 QA Profile(프로젝트 정책)

“어떤 체크를 실행/제외할지”

warn/limit 오버라이드

특정 부재/층/체크 예외(FAIL→WARN 허용, max_ratio 제한 등)

compare/regression 허용오차 정책

도구:

structai_qa_profile_import, structai_qa_profile_bind_model, structai_qa_profile_get_effective

9. 상용 비교 자동화(compare)
데이터 적재

benchmarks, benchmark_results에 CSV/JSON로 적재

비교 실행

compare_runs, compare_items에 diff 저장

severity:

OK / WARN / DIFF

MISSING_EXPECTED(bench 없음)

MISSING_ACTUAL(우리 결과 없음)

리포트

structai_compare_report_generate로 MD/PDF 생성 + artifacts 연결

10. 회귀(Regression) 하네스 + CI
핵심 설계 포인트

회귀는 반드시 isolated DB로 돌려 사용자 DB를 오염시키지 않음

fixture는 “도구 호출 steps”로 정의(내부 구현 변경에 강함)

golden은 결과 요약(metrics) 형태로 저장:

overall PASS/WARN/FAIL/NA counts

check_type별 worst_ratio 등

도구/구성

structai_regression_run_case (isolated DB + steps 실행)

structai_regression_run_suite_v2 (golden 비교 후 PASS/FAIL)

structai_regression_update_golden_case/suite

structai_regression_report_generate

CLI: mcp_server/regression_cli.py → GitHub Actions에서 FAIL 차단

VS Code QA 탭:

regression runs list/read

compare runs list/read

리포트 artifact 열기

11. 데이터셋 버전 관리(SemVer) + 변경관리(영향 분석)
Dataset Registry

type/name/version 단위로 artifact(원본 파일) 연결

active 버전을 1개로 고정(재현성)

도구:

structai_dataset_register

structai_dataset_set_active

structai_dataset_get_active_all

활성 버전 변경 이벤트 + 영향 분석 + 공지

structai_dataset_set_active_notify

dataset_activation_events 기록

entity_contexts를 기반으로 “구버전으로 계산된 최신 check_run”을 찾아 영향 모델 추출

project_events에 자동 공지 생성

12. 리포트 서명(무결성) + 승인(감사)
무결성 서명

기본: sha256 digest 저장

옵션: hmac-sha256 (환경변수 키로)

도구:

structai_report_sign

structai_report_verify

승인(단일 승인 + 다단계 승인)

Step12: approvals (단순 승인)

Step13: approval_workflow_defs + approval_instances + approval_votes

1차/2차/최종 승인

role 기반 투표 제한

distinct_actors 제약 가능

도구:

structai_workflow_import, structai_workflow_bind_project

structai_approval_request_v2, structai_approval_vote, structai_approval_read

13. 멀티프로젝트·멀티유저 권한 + 프로젝트 대시보드
조직 운영 핵심

프로젝트 단위로:

모델 묶기

멤버(사용자) 역할 부여

워크플로우 바인딩

승인 진행상태 추적

이벤트 피드(데이터셋 변경/승인 요청/승인 결정)

권한 체크

roles.permissions_json 기반

actor는 VS Code 설정/환경변수로 고정(STRUCTAI_ACTOR)

대시보드

mapping/spec coverage(%)

latest check summary(FAIL/WARN/NA)

approvals in progress

project events feed

도구:

structai_project_dashboard

structai_project_create, structai_project_bind_model, structai_project_add_member

structai_user_upsert, structai_role_upsert

14. VS Code 확장 UI 구성(최종 형태)
패널 구성(추천)

Chat Panel: AI 대화 + 도구 실행 + 근거 링크(artifacts)

Resolve Panel: suggested/confirmed/rejected + conflicts + missing + patch rollback

QA Panel: regression/compare 실행 + 리포트 열기

Projects Panel: 프로젝트 대시보드 + 이벤트 피드 + 멤버/역할

Governance Panel: 승인 인스턴스 목록/투표, 데이터셋 active 현황, 서명/검증

15. 파일/모듈 구조(권장 정리)
mcp_server/
  server.py                      # MCP tools, DB override, registry, permissions
  schema.sql                      # schema versions v0.1.0 ~ v0.1.4
  parsing/
    specs.py                      # steel/RC spec parsing
    story.py                      # story normalization
    table_schema_v2.py            # v2 table inference/parser
  design/
    steel_props.py                # H section
    steel_props_more.py           # BOX/PIPE/CHANNEL/ANGLE
    rc_beam_rect.py               # RC beam capacity (예시)
  checks/
    engine.py                     # rulepack eval + QA profile 적용(권장)
  reporting/
    compare.py                    # compare md/pdf
    regression.py                 # regression md/pdf
  regression_cli.py               # CI runner


VS Code Extension:

extension/
  src/
    mcp.ts                        # invoke wrapper
    views/
      resolveView.ts
      qaView.ts
      projectsView.ts
      governanceView.ts
  media/
    resolve/main.js
    qa/main.js

16. 운영 관점 “최소 성공 조건”(MVP → Production)
MVP(현장 테스트 가능한 최소)

DXF 표 인식(v2) + token-story mapping + spec apply + 체크 실행

patch rollback

보고서 생성(MD라도)

기본 rulepack/템플릿/코드북

Production(배포 가능한 품질)

회귀/CI(PASS/FAIL)

상용 비교 + diff report

QA 프로파일(예외/허용오차)

데이터셋 버전 관리 + 변경 공지/영향 분석

서명 + 승인 워크플로우(1차/2차/최종)

프로젝트 대시보드 + 권한 관리

17. “한 번에 돌리는” 통합 실행 예시(요약)
(1) 데이터셋/프로파일/룰 준비
#structai_dataset_register { "type":"section_catalog","name":"ks-steel","version":"2025.01.0","artifact_path":"datasets/ks_steel.csv","activate":true }
#structai_qa_profile_import { "path":"qa_profiles/qa_kds_prod.json", "activate":true }
#structai_templates_import { "path":"templates_kds_rc_core.json" }
#structai_templates_set_active { "name":"kds-rc-core","version":"2025.01" }
#structai_rulepack_generate_from_templates { "new_rulepack_name":"kds-rc-generated","new_rulepack_version":"2025.01","activate":true }

(2) DXF→매핑→적용→체크
#structai_import_dxf { "path":"fixtures/case01/S-101.dxf" }
#structai_cad_parse_specs { "cad_artifact_id": 1 }
#structai_cad_detect_story_tags { "cad_artifact_id": 1 }
#structai_cad_extract_tables { "cad_artifact_id": 1, "min_cells": 16 }
#structai_cad_infer_table_schemas_v2 { "cad_artifact_id": 1 }
#structai_token_story_map_build { "cad_artifact_id": 1, "model_id": 1 }
#structai_token_story_auto_confirm { "cad_artifact_id": 1, "model_id": 1 }
#structai_specs_from_table_rows { "cad_artifact_id": 1, "model_id": 1 }
#structai_specs_auto_confirm_table_schema { "cad_artifact_id": 1, "model_id": 1 }
#structai_design_apply_specs_to_inputs { "cad_artifact_id": 1, "model_id": 1, "overwrite_keys": false }
#structai_check_run { "model_id": 1, "analysis_run_id": 1 }

(3) 리포트 서명 + 승인
#structai_report_sign { "artifact_id": 123, "signer":"kim@company", "method":"sha256", "note":"검토 리포트" }
#structai_approval_request_v2 { "project_id": 1, "entity_type":"report", "entity_id": 123, "comment":"1차 승인 요청" }
#structai_approval_vote { "instance_id": 1, "decision":"approve", "comment":"OK" }

18. 마지막으로: 이 설계의 “핵심 강점” 요약

자동화(추출/매핑/적용) + 사람의 확정(Resolve) + 되돌리기(패치 롤백)

**표준값 우선(단면/조항)**으로 신뢰 확보

비교/회귀/CI로 결과 변경을 통제(품질 유지)

버전관리/서명/승인/권한/감사로 조직 운영까지 연결

즉, “AI 대화형 도구”를 넘어 실제로 배포 가능한 구조 엔지니어링 플랫폼 형태

원하면, 이 요약 계획서를 그대로 기반으로 **“레포지토리 초기 폴더 구조 + schema.sql 통합본 + server.py 통합본(도구 등록/권한/거버넌스 포함)”**까지 한 번에 정리한 “실제 코드 패키지 형태”로도 정돈해줄 수 있어.
