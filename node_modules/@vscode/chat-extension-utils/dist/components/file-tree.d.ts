import { BasePromptElementProps, PromptElement, PromptMetadata, PromptPiece, PromptSizing, TextChunk } from '@vscode/prompt-tsx';
import * as vscode from 'vscode';
export interface IFileTreeProps extends BasePromptElementProps {
    /**
     * Root URI to represent.
     */
    root: vscode.Uri;
    /**
     * If set to a subpath of the `root`, the file tree will focus on this this
     * URI and expand its children more eagerly than other URIs within the root.
     * This matters when the size of the file tree would exceed the token budget.
     */
    focusOn?: vscode.Uri;
    /**
     * An identifying token that can be used to identify the tree in {@link FileTreeMetadata}.
     */
    id?: unknown;
    /**
     * Function to use to test whether the given URIs are ignored. It should
     * filter the input list of URIs and *return any URIs that should be ignored*.
     */
    ignore?: (uris: vscode.Uri[]) => vscode.Uri[] | Promise<vscode.Uri[]>;
}
export type ParsedTextFileTree = {
    name: string;
    children?: ParsedTextFileTree[];
};
export type ParsedUriFileTree = {
    uri: vscode.Uri;
    children?: ParsedUriFileTree[];
};
/**
 * This represents a file tree at the given URI or URIs in an indented format,
 * such as:
 *
 * ```
 * src/
 *   foo.js
 *   bar.js
 *   baz/
 *     qux.js
 * package.json
 * README.md
 * ```
 *
 * You can pass an `ignore` function to use to filter paths in the tree.
 *
 * This element *is* responsive to the token budget, so you should generally
 * use this with a `flexGrow` value. See
 * https://github.com/microsoft/vscode-prompt-tsx?tab=readme-ov-file#flex-behavior
 *
 * The FileTree can also `focusOn` a specific subpath within the root URI. In
 * this case, it will start expanding outwards from the given subpath, but it
 * still will include the path from the root to that subpath. For example,
 * in the above file tree with a `focusOn` the `src` directory, it might
 * include the contents of `src` only if it has a very small budget:
 *
 * ```
 * src/
 *   foo.js
 *   bar.js
 *   baz/
 * ```
 */
export declare class FileTree extends PromptElement<IFileTreeProps> {
    /**
     * Parses a tree in the format of the `FileTree` element and returns the
     * resulting list of URIs. This is useful if you give the filetree to
     * the a model as ask it for results.
     *
     * @param includeDirectories If set to true, directories will be included in the result.
     * If false or not given, only the files will be returned.
     */
    static parseUris(root: vscode.Uri, tree: string): ParsedUriFileTree[];
    /**
     * Parses a tree in the format of the `FileTree` element and returns the
     * resulting structure. This is useful if you give the filetree to
     * the a model as ask it for results.
     */
    static parseText(tree: string): ParsedTextFileTree[];
    render(): PromptPiece;
}
export interface IFileTreeFragmentProps extends IFileTreeProps {
    /** Starting indentation level (defaults to 0) */
    indent?: number;
}
/**
 * Like the {@link FileTree}, but can start at a customizable indentation level
 * and lacks surrounding code fences to allow for composition.
 */
export declare class FileTreeFragment extends PromptElement<IFileTreeFragmentProps> {
    render(_state: void, sizing: PromptSizing, _progress?: unknown, token?: vscode.CancellationToken): Promise<any>;
    private fileTree;
}
export declare class FileTreeMetadata extends PromptMetadata {
    private readonly root;
    readonly id: unknown;
    constructor(root: Node, id: unknown);
    /** Gets all URIs represented in the file tree, including directories. */
    uris(): Generator<vscode.Uri, any, any>;
    /** Gets all file URIs represented in the file tree. */
    files(): Generator<vscode.Uri, any, any>;
}
declare class Node {
    readonly uri: vscode.Uri;
    readonly parent: Node | undefined;
    readonly indent: number;
    readonly priority: number;
    /** Defined only for directories */
    readonly children?: Node[];
    constructor(uri: vscode.Uri, parent: Node | undefined, indent: number, kind: vscode.FileType, priority: number);
    get text(): string;
    toSubtree(): Generator<TextChunk>;
    uris(filesOnly: boolean): Generator<vscode.Uri>;
}
export {};
