"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolResultMetadata = exports.ToolCall = void 0;
const prompt_tsx_1 = require("@vscode/prompt-tsx");
const vscode = require("vscode");
/**
 * An element that can be included in your prompt to call a tool and include
 * its invocation result in the prompt. This element *is* responsive to the
 * token budget, so you should generally use this with a `flexGrow` value.
 * See https://github.com/microsoft/vscode-prompt-tsx?tab=readme-ov-file#flex-behavior
 *
 * To use this, you generally first build your prompt and make a request and
 * include the available tools, for example:
 *
 * ```
 * const options: vscode.LanguageModelChatRequestOptions = {
 *     justification: 'To collaborate on diagrams',
 * };
 *
 * options.tools = vscode.lm.tools.map((tool): vscode.LanguageModelChatTool => {
 *     return {
 *         name: tool.name,
 *         description: tool.description,
 *         inputSchema: tool.inputSchema ?? {}
 *     };
 * });
 *
 * // ...
 * const response = makeRequestWithOptions(options);
 * ```
 *
 * If the response contains {@link vscode.LanguageModelToolCallPart}, then you
 * should re-send the prompt with a {@link ToolCall} element for each of those.
 *
 * ```
 * class MyElement extends PromptElement<IProps> {
 *    render() {
 *       return (
 *         <UserMessage>
 *           // ...
 *         </UserMessage>
 *         {this.props.toolCalls.map(call => <ToolCall call={call} invokationToken={chatRequest.toolInvocationToken} />)}
 *      );
 *    }
 * }
 * ```
 *
 * This element will automatically call `vscode.lm.invokeTool` and include
 * the result appropriately.
 */
class ToolCall extends prompt_tsx_1.PromptElement {
    async render(_state, sizing, _progress, token) {
        const tool = vscode.lm.tools.find(t => t.name === this.props.call.name);
        if (!tool) {
            return vscpp(prompt_tsx_1.ToolMessage, { toolCallId: this.props.call.callId }, "Tool not found");
        }
        const tokenizationOptions = {
            tokenBudget: sizing.tokenBudget,
            countTokens: async (content) => sizing.countTokens(content),
        };
        const toolResult = this.props.result ||
            (await vscode.lm.invokeTool(this.props.call.name, {
                input: this.props.call.input,
                toolInvocationToken: this.props.invocationToken,
                tokenizationOptions,
            }, token));
        return (vscpp(prompt_tsx_1.ToolMessage, { toolCallId: this.props.call.callId },
            vscpp("meta", { value: new ToolResultMetadata(this.props.call.callId, toolResult), local: true }),
            vscpp(prompt_tsx_1.ToolResult, { data: toolResult })));
    }
}
exports.ToolCall = ToolCall;
/** Metadata returned for each tool call. */
class ToolResultMetadata extends prompt_tsx_1.PromptMetadata {
    constructor(toolCallId, result) {
        super();
        this.toolCallId = toolCallId;
        this.result = result;
    }
}
exports.ToolResultMetadata = ToolResultMetadata;
