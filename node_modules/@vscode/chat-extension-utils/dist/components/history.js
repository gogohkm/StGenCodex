"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.HistoryMessages = exports.History = void 0;
const prompt_tsx_1 = require("@vscode/prompt-tsx");
const vscode_1 = require("vscode");
/**
 * This shows a list of history messages with more recent history messages
 * at a higher priority than older messages.
 *
 * `prompt-tsx` has a `passPriority` attribute which allows an element to act
 * as a 'pass-through' container, so that its children are pruned as if they
 * were direct children of the parent. With this component, the elements:
 *
 * ```
 * <HistoryMessages history={history.slice(0, -2)} priority={0} />
 * <HistoryMessages history={history.slice(-2)} priority={80} />
 * ```
 *
 * ...can equivalently be expressed as:
 *
 * ```
 * <History history={history} passPriority older={0} recentPriority={80} />
 * ```
 */
class History extends prompt_tsx_1.PromptElement {
    render() {
        const { n = 2, older, newer, history } = this.props;
        return (vscpp(vscppf, null,
            vscpp(HistoryMessages, { history: history.slice(0, -n), priority: older }),
            vscpp(HistoryMessages, { history: history.slice(-n), priority: newer })));
    }
}
exports.History = History;
/**
 * The History element simply lists user and assistant messages from the chat
 * context. If things like tool calls or file trees are relevant for, your
 * case, you can make this element more complex to handle those cases.
 */
class HistoryMessages extends prompt_tsx_1.PromptElement {
    render() {
        return (vscpp(prompt_tsx_1.PrioritizedList, { priority: 0, descending: false }, this.props.history.map(this.props.renderTurn || defaultRenderTurn)));
    }
}
exports.HistoryMessages = HistoryMessages;
const defaultRenderTurn = (turn) => {
    if (turn instanceof vscode_1.ChatRequestTurn) {
        return vscpp(prompt_tsx_1.UserMessage, null, turn.prompt);
    }
    else if (turn instanceof vscode_1.ChatResponseTurn) {
        return vscpp(prompt_tsx_1.AssistantMessage, null, chatResponseToMarkdown(turn));
    }
    else {
        return vscpp(vscppf, null);
    }
};
const chatResponseToMarkdown = (response) => {
    let str = '';
    for (const part of response.response) {
        if (part instanceof vscode_1.ChatResponseMarkdownPart) {
            str += part.value.value;
        }
        else if (part instanceof vscode_1.ChatResponseAnchorPart) {
            if (part.title) {
                str += `[${part.title}](`;
            }
            const uri = part.value instanceof vscode_1.Uri ? part.value : part.value.uri;
            if (uri.scheme === 'file') {
                str += uri.fsPath;
            }
            else {
                str += uri.toString();
            }
            if (part.title) {
                str += ')';
            }
        }
    }
    return str;
};
