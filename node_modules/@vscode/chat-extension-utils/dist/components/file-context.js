"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilesContext = void 0;
const prompt_tsx_1 = require("@vscode/prompt-tsx");
const vscode_1 = require("vscode");
/**
 * This component includes the contents of the files provided to it, centered
 * around the given ranges. It expands the files line-by-line until the budget
 * it's given is exhausted, or when the entire file contents is included.
 *
 * This is best used with `flexGrow`, see the example in
 * `./examples/file-contents.tsx` for a demonstration.
 */
class FilesContext extends prompt_tsx_1.PromptElement {
    async render(_state, sizing) {
        const files = await this.getExpandedFiles(sizing);
        return (vscpp(vscppf, null, files.map(f => (vscpp(prompt_tsx_1.Chunk, null,
            vscpp("references", { value: [new prompt_tsx_1.PromptReference(f.toLocation())] }),
            f.toString())))));
    }
    /**
     * The idea here is:
     *
     * 1. We wrap each file in markdown-style code fences, so get the base
     *    token consumption of each of those.
     * 2. Keep looping through the files. Each time, add one line from each file
     *    until either we're out of lines (anyHadLinesToExpand=false) or until
     *    the next line would cause us to exceed our token budget.
     *
     * This always will produce files that are under the budget because
     * tokenization can cause content on multiple lines to 'merge', but it will
     * never exceed the budget.
     *
     * (`tokenLength(a) + tokenLength(b) <= tokenLength(a + b)` in all current
     * tokenizers.)
     */
    async getExpandedFiles(sizing) {
        const fileInput = this.props.files instanceof Array ? this.props.files : [this.props.files];
        const allInputs = await Promise.all(fileInput.map(f => FileContextTracker.create(f)));
        const files = allInputs.filter(f => !!f);
        let tokenCount = 0;
        // count the base amount of tokens used by the files:
        for (const file of files) {
            tokenCount += await file.baseTokenCount(sizing);
        }
        while (true) {
            let anyHadLinesToExpand = false;
            for (const file of files) {
                const nextLine = file.nextLine();
                if (nextLine === undefined) {
                    continue;
                }
                anyHadLinesToExpand = true;
                const nextTokenCount = await sizing.countTokens(nextLine);
                if (tokenCount + nextTokenCount > sizing.tokenBudget) {
                    return files;
                }
                file.expand();
                tokenCount += nextTokenCount;
            }
            if (!anyHadLinesToExpand) {
                return files;
            }
        }
    }
}
exports.FilesContext = FilesContext;
class FileContextTracker {
    static async create(f) {
        if (typeof f.value === 'string') {
            return new FileContextTracker(new StringTextDocument(f.value, vscode_1.Uri.from({
                scheme: 'untitled',
                path: crypto.randomUUID(),
            })), f);
        }
        else if (f.value instanceof vscode_1.Uri || f.value instanceof vscode_1.Location) {
            const uri = f.value instanceof vscode_1.Location ? f.value.uri : f.value;
            try {
                const contents = await vscode_1.workspace.fs.readFile(uri);
                const text = new TextDecoder().decode(contents);
                return new FileContextTracker(new StringTextDocument(text, uri), f);
            }
            catch {
                return new FileContextTracker(new StringTextDocument('Failed to read file', uri), f);
            }
        }
        else if (!!f.value && 'uri' in f.value && 'isUntitled' in f.value) {
            return new FileContextTracker(f.value, f);
        }
        else {
            return undefined;
        }
    }
    constructor(document, { range, label, expand, value }) {
        this.document = document;
        this.suffix = '\n```\n';
        this.lines = [];
        this.nextLineIs = 'above';
        this.minLine = 0; // inclusive
        this.prefix = `# ${label || this.document.uri.fsPath}\n\`\`\`\n`;
        const actualRange = range || (value instanceof vscode_1.Location ? value.range : undefined);
        if (expand === false && actualRange) {
            this.minLine = actualRange.start.line;
            this.maxLine = actualRange.end.line + 1;
        }
        else {
            this.maxLine = this.document.lineCount;
        }
        this.aboveLine = this.belowLine = actualRange
            ? actualRange.start.line + Math.floor((actualRange.end.line - actualRange.start.line) / 2)
            : 0;
    }
    /** Counts the length of the base prefix/suffix. */
    async baseTokenCount(sizing) {
        const before = await sizing.countTokens(this.prefix);
        const after = await sizing.countTokens(this.suffix);
        return before + after;
    }
    /** Gets the next line that will be added on the following `expand` call. */
    nextLine() {
        switch (this.nextLineIs) {
            case 'above':
                return this.document.lineAt(this.aboveLine).text + '\n';
            case 'below':
                return this.document.lineAt(this.belowLine).text + '\n';
            case 'none':
                return undefined;
        }
    }
    /** Adds in the 'next line' */
    expand() {
        if (this.nextLineIs === 'above') {
            this.lines.unshift(this.document.lineAt(this.aboveLine).text);
            if (this.belowLine < this.maxLine - 1) {
                this.belowLine++;
                this.nextLineIs = 'below';
            }
            else if (this.aboveLine > this.minLine) {
                this.aboveLine--;
            }
            else {
                this.nextLineIs = 'none';
            }
        }
        else if (this.nextLineIs === 'below') {
            this.lines.push(this.document.lineAt(this.belowLine).text);
            if (this.aboveLine > this.minLine) {
                this.aboveLine--;
                this.nextLineIs = 'above';
            }
            else if (this.belowLine < this.maxLine - 1) {
                this.belowLine++;
            }
            else {
                this.nextLineIs = 'none';
            }
        }
    }
    toLocation() {
        return new vscode_1.Location(this.document.uri, new vscode_1.Range(this.aboveLine, 0, this.belowLine, 0));
    }
    /** Gets the file content as a string. */
    toString() {
        return this.prefix + this.lines.join('\n') + this.suffix;
    }
}
class StringTextDocument {
    get lineCount() {
        return this.lines.length;
    }
    constructor(contents, uri) {
        this.uri = uri;
        this.lines = contents.split('\n');
    }
    lineAt(line) {
        return { text: this.lines[line] || '' };
    }
}
