"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation and GitHub. All rights reserved.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTestDir = exports.getResultTextWithMessageTypes = exports.getResultText = exports.renderTestPrompt = exports.charTokenizer = void 0;
exports.createFileTree = createFileTree;
const prompt_tsx_1 = require("@vscode/prompt-tsx");
const crypto_1 = require("crypto");
const fs = require("fs");
const os_1 = require("os");
const path = require("path");
const vscode = require("vscode");
/** Simple tokenizer used for tests */
exports.charTokenizer = {
    async countMessageTokens(message) {
        return (await this.tokenLength(message.content)) + 3;
    },
    tokenLength(text) {
        return Math.ceil((text.length * 3) / 4);
    },
};
const renderTestPrompt = (opts) => (0, prompt_tsx_1.renderPrompt)(opts.ctor, opts.props, { modelMaxPromptTokens: opts.budget }, exports.charTokenizer, undefined, undefined, 'vscode');
exports.renderTestPrompt = renderTestPrompt;
const getResultText = (r) => {
    let text = '';
    for (const m of r.messages) {
        for (const content of m.content) {
            if (content instanceof vscode.LanguageModelTextPart) {
                text += content.value;
            }
        }
    }
    return text;
};
exports.getResultText = getResultText;
const getResultTextWithMessageTypes = (r) => {
    let text = '';
    for (const m of r.messages) {
        text += `${m.role}: `;
        for (const content of m.content) {
            if (content instanceof vscode.LanguageModelTextPart) {
                text += content.value;
            }
        }
        text += '\n';
    }
    return text;
};
exports.getResultTextWithMessageTypes = getResultTextWithMessageTypes;
// https://github.com/microsoft/vscode-js-debug/blob/c57467fb349a2b99073424035b3785d8381357aa/src/test/createFileTree.ts#L17
function createFileTree(rootDir, tree) {
    fs.mkdirSync(rootDir, { recursive: true });
    for (const key of Object.keys(tree)) {
        const value = tree[key];
        const targetPath = path.join(rootDir, key);
        let write;
        if (typeof value === 'string') {
            write = Buffer.from(value);
        }
        else if (value instanceof Array) {
            write = Buffer.from(value.join(os_1.EOL));
        }
        else {
            createFileTree(targetPath, value);
            continue;
        }
        fs.mkdirSync(path.dirname(targetPath), { recursive: true });
        fs.writeFileSync(targetPath, write);
    }
}
const getTestDir = () => path.join((0, os_1.tmpdir)(), 'tsx-elements-test-' + (0, crypto_1.randomBytes)(6).toString('hex'));
exports.getTestDir = getTestDir;
